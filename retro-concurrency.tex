\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Custom definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{balance}
\usepackage{url}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{multirow}
\usepackage{microtype}
\usepackage{soul,xcolor}
\usepackage{mathpartir}
\usepackage{amsmath,amsthm}
\usepackage[utf8]{inputenc}
\input{unicode-preamble.tex}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes}
\usepackage{stmaryrd}

\crefformat{section}{§#2#1#3}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{nop}{}{}
\newenvironment{smathpar}{
\begin{nop}\small\begin{mathpar}}{
\end{mathpar}\end{nop}\ignorespacesafterend}

\newcommand{\kc}[1]{{\color{red} {\it [KC says: #1]}}}
\newcommand{\am}[1]{{\color{blue} {\it [AM says: #1]}}}

\definecolor{Bittersweet}{rgb}{1.0, 0.44, 0.37}
\definecolor{MidnightBlue}{rgb}{0.0, 0.2, 0.4}
\definecolor{BrightBlue}{rgb}{0.0, 0.2, 0.7}
\definecolor{byzantine}{rgb}{0.74, 0.2, 0.64}
\definecolor{caribbeangreen}{rgb}{0.0, 0.8, 0.6}

\lstset{
			language=[Objective]caml,
      basicstyle=\ttfamily\small,
      flexiblecolumns=false,
			tabsize=2,
      escapechar=',
      %basewidth={0.5em,0.45em},
      %aboveskip={3pt},
      %belowskip={3pt},
			breaklines = true,
      breakatwhitespace = true,
      keywordstyle=\color{Bittersweet}\bfseries,
      commentstyle=\color{blue}\itshape,
      stringstyle=\color{MidnightBlue},
			keywords=[1]{effect,perform,continue,discontinue},
			keywordstyle=[1]\color{Bittersweet}\bfseries,
			keywords=[2]{},
			keywordstyle=[2]\color{byzantine}\bfseries,
			keywords=[3]{int,string}, %types%
			keywordstyle=[3]\color{caribbeangreen},
			classoffset=1,
			upquote=true,
			keywordstyle=\color{byzantine}\bfseries,
			classoffset=0,
			mathescape=true,
			numberstyle=\tiny\color{gray},
			numbersep=2pt
}

\lstnewenvironment{code}[1][]
    { % \centering
      \lstset{
				basicstyle=\ttfamily\footnotesize,
				#1}%
      \csname lst@setfirstlabel\endcsname}
    { %\centering
      \csname lst@savefirstlabel\endcsname}

\lstMakeShortInline[columns=fullflexible]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Semantics definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\olam}[2]{\lambda^o #1. #2}
\newcommand{\llambda}{\lambda\!\!\lambda}
\newcommand{\clam}[2]{\lambda^c #1. #2}
\newcommand{\lam}[2]{\Lambda #1. #2}

\newcommand{\env}{\epsilon}
\newcommand{\envext}[3]{#1[#2 \mapsto #3]}

\newcommand{\oclos}[3]{\llparenthesis \olam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\cclos}[3]{\llparenthesis \clam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\clos}[3]{\llparenthesis \lam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\kw}[1]{\text{\bf #1}}
\newcommand{\effval}[2]{\textsf{do} ~#1 ~#2}
\newcommand{\exnval}[1]{\textsf{exn} ~#1}

\newcommand{\handle}[2]{\kw{match} ~#1 ~\kw{with} ~#2}
\newcommand{\throw}[2]{\kw{raise} ~#1 ~#2}
\newcommand{\perform}[2]{\kw{perform} ~#1 ~#2}

\newcommand{\caseval}[2]{\kw{return}~#1 \mapsto #2}
\newcommand{\caseexn}[3]{\kw{exception} ~#1 ~#2 \mapsto #3}
\newcommand{\caseeff}[4]{\kw{effect} ~#1 ~#2 ~#3 \mapsto #4}

\newcommand{\farg}[2]{\langle #1 ~#2 \rangle_a}
\newcommand{\ffun}[1]{\langle #1 \rangle_f}
\newcommand{\faritha}[3]{\langle #1 ~#2 ~#3 \rangle_{b1}}
\newcommand{\farithb}[2]{\langle #1 ~#2 \rangle_{b2}}

\newcommand{\kcons}{\lhd}
\newcommand{\fiber}{\varphi}
\newcommand{\fl}{\psi} % Frame List
\newcommand{\hc}{\eta} % Handler Closure

\newcommand{\cstack}{\gamma} % C Stack
\newcommand{\ostack}{\omega} % OCaml Stack
\newcommand{\cstacka}[2]{\big \lceil #1, #2 \big \rceil_c} % C stack with arguments
\newcommand{\ostacka}[2]{\big \lceil #1, #2 \big \rceil_o} % OCaml stack with arguments
\newcommand{\ostackemp}{\bullet}
\newcommand{\stack}{\sigma}

\newcommand{\term}{\tau}
\newcommand{\config}{\mathfrak{C}}
\newcommand{\configa}[3]{\|#1,#2,#3\|}

\newcommand{\ostep}{\xrightarrow{o}}
\newcommand{\cstep}{\xrightarrow{c}}
\newcommand{\step}{\rightarrow}

\begin{document}

\title{Retrofitting Effect Handlers onto OCaml}

\begin{abstract}
	Effect handlers have gained immense interest in the recent years as a means
	for modular programming with user-defined effects. The runtime semantics of
	effect handlers is particularly attractive as they allow advanced control
	flow mechanisms such as first-class continuations, generators, async/await,
	coroutines to be composably expressed. In this paper, we present the design,
	a full-fledged implementation and evaluation of effect handlers for OCaml, an
	industrial-strength, multi-paradigm programming language. OCaml tends to be
	widely used for systems programming, and is compatible with program analysis
	tools that inspect the stack such as debuggers and profilers. Retrofitting
	effect handlers onto OCaml is challenging since OCaml does not have any
	non-local control flow mechanisms other than exceptions. Our implementation
	of effect handlers for OCaml imposes negligible overhead on code that does
	not use effect handlers, and remains compatible with program analysis tools
	that inspect the stack.
\end{abstract}

\maketitle

\section{Introduction}

Effect Handlers~\cite{Plotkin09} provide a modular foundation for user-defined
effects. The key idea is to separate the definition of the effectful
\emph{operations} from their interpretations, which are defined by
\emph{handlers} of the effects. For example, |effect Read : in_channel -> string|
declares an effect |Read|, which is parametrised with an input channel of type
|in_channel|, which when \emph{performed} returns a |string| value. A
computation can perform the |Read| effect without knowing how the |Read| effect
is implemented. This computation may be enclosed by different handlers that
interpret |Read| differently. For example, |Read| may be implemented by
performing a blocking read on the input channel or performing the read
asynchronously by offloading it to an event loop such as |libuv|. Thanks to the
separation of effectful operations from their interpretations, effect handlers
enable new approaches to modular programming. A computation may perform many
different effects, which are interpreted by one or more enclosing handlers.

What makes effect handlers quite powerful is that they provide a structured
form of delimited continuations, which enables advanced non-local control-flow
mechanisms such as resumable exceptions, coroutines, generators and
asynchronous I/O to be composably expressed. As an example, consider the task
of handling division-by-zero case in a calculator application. Different
calculators handle division-by-zero differently. In the iOS 13 Calculator App,
division-by-zero returns |Error|. In the Google Search Calculator App |0/0|
returns to |Error|, and for any other |n| not equal to |0|, |n/0| returns
|Infinity| with the same sign as |n|. In the OCaml top-level, division-by-zero
raises |Division_by_zero| exception. How can we capture these different
behaviours without changing the evaluator?

Common Lisp Conditions~\cite{Conditions} are an elegant way to solve this
problem. Unlike exceptions where the library decides whether an error is fatal
or not, conditions allow the client of the library to make that decision.
Common Lisp Conditions provide a restart mechanism to resume execution from the
point where the condition was signalled. On division-by-zero, the calculator
signals the handler and lets the handler decide the course of action based on
the desired semantics. We can implement this mechanism using effect handlers as
shown in Figure~\ref{fig:}.

The search for an expressive effect system which guarantees that all the
effects performed in the program are handled (\emph{effect safety}) in the
presence of advanced features such as polymorphism, modularity and generativity
is an active area of research~\cite{Leijen14, Biernacki19, Biernacki20,
Hillerstrom20}. We do not focus on this question in this paper, and the
implementation of effect handlers in Multicore OCaml does not guarantee effect
safety.

\section{Background: OCaml Stacks}

\section{Handlers by example}

\section{Semantics}

The initial configuration for an expression $e$ is
$\configa{e}{\emptyset}{\cstacka{[]}{\bullet}}$. We define {\sf continue} and
{\sf discontinue} as follows:

\begin{smathpar}
	\begin{array}{rcl}
		\textsf{continue} ~k ~e & = & k ~(\olam{x}{x}) ~e \\
		\textsf{discontinue} ~k ~l ~e & = & k ~(\olam{x}{\throw{l}{x}}) ~e
	\end{array}
\end{smathpar}

\begin{figure*}
	\begin{minipage}[t]{0.49\linewidth}
	\begin{smathpar}
	\begin{array}{rrcl}
		\text{Constants} & n & \coloneqq & ℤ \\
		\text{Abstractions} & \Lambda & \coloneqq & \lambda^o \mid \lambda^c \\
		\text{Expressions} & e & \coloneqq & n \mid x \mid e ~e \mid  \lam{x}{e} \mid e \odot e \mid \throw{l}{e} \\
											 &   & \mid      & \handle{e}{h} \mid \perform{l}{e} \\
		\text{Handlers} & h & \coloneqq & \{\caseval{x}{e}\} \mid \{\caseexn{l}{x}{e}\} \uplus h \\
		               &   & \mid & \{\caseeff{l}{x}{k}{e}\} \uplus h \\
		\text{Values} & v & \coloneqq & n \mid k \mid \clos{x}{e}{\env} \mid \effval{l}{k} \mid \exnval{l} \\
		\text{Frames} & r & \coloneqq & \farg{e}{\env} \mid \ffun{v} \mid \faritha{\odot}{e}{\env} \mid \farithb{\odot}{ℕ} \\
		\text{Environments} & \env & \coloneqq & \emptyset \mid \envext{\env}{x}{v} \\
	\end{array}
	\end{smathpar}
	\end{minipage}
	\begin{minipage}[t]{0.49\linewidth}
	\begin{smathpar}
	\begin{array}{rrcl}
		\text{Handler Closures} & \hc & \coloneqq & (h,\env) \\
		\text{Frame List} & \fl & \coloneqq & [] \mid r :: \fl \\
		\text{Fibers} & \fiber & \coloneqq & (\fl, \hc) \\
		\text{Continuations} & k & \coloneqq & [] \mid \fiber \lhd k \\
		\text{C stacks} & \cstack & \coloneqq & \cstacka{\fl}{\ostack}\\
		\text{OCaml stacks} & \ostack & \coloneqq & \ostacka{k}{\cstack} \mid \ostackemp \\
		\text{Stacks} & \stack & \coloneqq & \cstack \mid \ostack \\
		\text{Terms} & \term & \coloneqq & e \mid v \\
		\text{Configurations} & \config & \coloneqq & \configa{\tau}{\env}{\stack}
	\end{array}
	\end{smathpar}
	\end{minipage}
	\caption{Term Syntax}
	\label{sem:syntax}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcl}
			\textsc{Var}     & (x,\env, \fl) & \rightsquigarrow
			                 & (\env(x), \env, \fl) \\
			\textsc{Arith1}  & (e_1 \odot e_2, \env, \fl) & \rightsquigarrow
			                 & (e_1,\env, \faritha{\odot}{e_2}{\env}::\fl) \\
			\textsc{Arith2}  & (n_1, \_, \faritha{\odot}{e_2}{\env}::\fl) & \rightsquigarrow
			                 & (e_2, \env, \farithb{\odot}{n_1}::\fl) \\
			\textsc{Arith3}  & (n_2, \env, \farithb{\odot}{n_1}::\fl) & \rightsquigarrow
			                 & (\llbracket n_1 \odot n_2 \rrbracket, \env, \fl) \\
			\textsc{App1}    & (e_1 ~e_2, \env, \fl) & \rightsquigarrow
			                 & (e_1, \env, \farg{e_2}{\env}::\fl) \\
			\textsc{App2}    & (\lam{x}{e}, \env, \fl) & \rightsquigarrow
			                 & (\clos{x}{e}{\env}, \env, \fl) \\
			\textsc{App3}    & (\clos{x}{e_1}{\env_1}, \_, \farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_2, \env_2, \ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
			\textsc{Resume1} & (k,\_,\farg{e_1}{\env_1}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_1, \env_1, \ffun{k}::\farg{e_2}{\env_2}::\fl) \\
			\textsc{Resume2} & (\clos{x}{e_1}{\env_1}, \_, \ffun{k}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_2, \env_2, \ffun{k}::\ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
			\textsc{Perform} & (\perform{l}{e}, \env, \fl) & \rightsquigarrow
			                 & (e, \env, \ffun{\effval{l}{[[],(\{\caseval{x}{x}\},\emptyset)]}}::\fl) \\
			\textsc{Raise}   & (\throw{l}{e}, \env, \fl) & \rightsquigarrow
											 & (e, \env, \ffun{\exnval{l}}::\fl)
		\end{array}
	\end{smathpar}
	\caption{Local Reductions -- $(\term, \env, \fl) \rightsquigarrow (\tau, \env, \fl)$.}
	\label{sem:step}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcll}
			\textsc{LocalO}   & (\term,\env,(\fl,\hc) \kcons k,\cstack) & \ostep
												& \configa{\term'}{\env'}{\ostacka{(\fl',\hc) \kcons k}{\cstack}}
												& \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
			\textsc{RetC}   & (v, \_, [([],(h,\env))], \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\cstack}
												& \text{if } \{\caseval{x}{e}\} \in h \\
			\textsc{RetFib} & (v, \_, ([],(h,\env)) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstack}}
												& \text{if } \{\caseval{x}{e}\} \in h \\
			\textsc{CallO}    & (v, \_, (\oclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{(\fl,\hc) \kcons k}{\cstack}} \\
			\textsc{ExtCall}  & (v, \_, (\cclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\cstacka{[]}{\ostacka{(\fl,\hc) \kcons k}{\cstack}}} \\
			\textsc{Resume}   & (v, \_, (\ffun{k}::\ffun{\oclos{x}{e}{\env}}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k ~@~ (\fl,\hc) \kcons k'}{\cstack}} \\
			\textsc{Handle}   & (\handle{e}{h}, \env, k, \cstack) & \ostep
												& \configa{e}{\env}{\ostacka{([],(h,\env)) \kcons k}{\cstack}} \\
			\textsc{EffUnHn}  & (v, \_, [\ffun{\effval{l}{k}}::\fl,(h,\env)], \cstack) & \ostep
												& \configa{e}{\emptyset}{\ostacka{k ~@~ [(\fl,(h,\env))]}{\cstack}}
												& \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
									& & & & \text{and } {e = \throw{\textsf{unhandled}}{0}} \\
			\textsc{EffHn}    & (v, \_, (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons k', \cstack) & \ostep
												& \configa{e}{\env[r \mapsto k''][x \mapsto v]}{\ostacka{k'}{\cstack}}
												& \text{if } \{\caseeff{l}{x}{r}{e}\} \in h \\
									& & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
			\textsc{EffFwd}   & (v, \env', (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
												& \configa{v}{\env'}{\ostacka{(\ffun{\effval{l}{k''}}::\fl',\hc') \kcons k'}{\cstack}}
												& \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
								  & & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
			\textsc{ExFwdC}   & (v, \env, [\ffun{\exnval{l}}::\_,(h,\_)], \cstacka{\fl'}{\ostack}) & \ostep
												& \configa{v}{\env}{\cstacka{\ffun{\exnval{l}}::\fl'}{\ostack}}
												& \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
			\textsc{ExHn}     & (v, \_, (\ffun{\exnval{l}}::\_,(h,\env)) \kcons k', \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k'}{\cstack}}
												& \text{if } \{\caseexn{l}{x}{e}\} \in h \\
			\textsc{ExFwdFib} & (v, \env, (\ffun{\exnval{l}}::\_,(h,\_)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
												& \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl',\hc') \kcons k'}{\cstack}}
												& \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
		\end{array}
	\end{smathpar}
	\caption{OCaml Reductions -- $(\term, \env, k, \cstack) \ostep \config$.}
	\label{sem:ostep}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcll}
			\textsc{LocalC}   & (\term,\env,\fl,\ostack) & \cstep
												& \configa{\term'}{\env'}{\cstacka{\fl'}{\ostack}}
												& \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
			\textsc{RetToO}   & (v,\env,[],\ostacka{k}{\cstack}) & \cstep
			                  & \configa{v}{\env}{\ostacka{k}{\cstack}} \\
			\textsc{CallC}    & (v, \_, \cclos{x}{e}{\env}::\fl, \ostack) & \cstep
												& \configa{e}{\envext{\env}{x}{v}}{\cstacka{\fl}{\ostack}} \\
			\textsc{Callback} & (v, \_, \oclos{x}{e}{\env}::\fl, \ostack) & \cstep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstacka{\fl}{\ostack}}}
												& \text{if } k = [[],(\{\caseval{x}{x}\},\emptyset)] \\
			\textsc{ExnFwdO}  & (v, \env, \ffun{\exnval{l}}::\_, \ostacka{(\fl,\hc) \kcons k}{\cstack}) & \cstep
												& \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl,\hc) \kcons k}{\cstack}}
		\end{array}
	\end{smathpar}
	\caption{C Reductions -- $(\term, \env, \fl, \ostack) \cstep \config$.}
	\label{sem:cstep}
\end{figure*}

\begin{figure*}
	\begin{mathpar}
		\begin{array}{rc}

			\textsc{StepC} & \inferrule
			                    {(\term, \env, \fl, \ostack) \cstep \config}
													{\configa{\term}{\env}{\cstacka{\fl}{\ostack}} \step \config} \\ \\
			\textsc{StepO} & \inferrule
													{(\term, \env, k, \cstack) \ostep \config}
													{\configa{\term}{\env}{\ostacka{k}{\cstack}} \step \config}
		\end{array}
	\end{mathpar}
	\caption{Top-level Reductions -- $\config \step \config$.}
	\label{sem:top}
\end{figure*}

\section{Implementation}

\section{Evaluation}

\section{Related Work}

\section{Conclusions and Future Work}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}


\end{document}
