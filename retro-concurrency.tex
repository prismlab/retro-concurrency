\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Custom definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{balance}
\usepackage{url}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{multirow}
\usepackage{microtype}
\usepackage{soul,xcolor}
\usepackage{mathpartir}
\usepackage{amsmath,amsthm}
\usepackage[utf8]{inputenc}
\input{unicode-preamble.tex}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes}
\usepackage{stmaryrd}

\crefformat{section}{§#2#1#3}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{nop}{}{}
\newenvironment{smathpar}{
\begin{nop}\small\begin{mathpar}}{
\end{mathpar}\end{nop}\ignorespacesafterend}

\newcommand{\kc}[1]{{\color{red} {\it [KC says: #1]}}}
\newcommand{\am}[1]{{\color{blue} {\it [AM says: #1]}}}

\definecolor{Bittersweet}{rgb}{1.0, 0.44, 0.37}
\definecolor{MidnightBlue}{rgb}{0.0, 0.2, 0.4}
\definecolor{BrightBlue}{rgb}{0.0, 0.2, 0.7}
\definecolor{byzantine}{rgb}{0.74, 0.2, 0.64}
\definecolor{caribbeangreen}{rgb}{0.0, 0.8, 0.6}

\lstset{
			language=caml,
      basicstyle=\ttfamily\footnotesize,
      flexiblecolumns=false,
			tabsize=2,
			escapechar={<@}{@>},
      %basewidth={0.5em,0.45em},
      %aboveskip={3pt},
      %belowskip={3pt},
			breaklines = true,
      breakatwhitespace = true,
      keywordstyle=\color{Bittersweet}\bfseries,
      commentstyle=\color{blue}\itshape,
      stringstyle=\color{MidnightBlue},
			keywords=[2]{},
			keywordstyle=[2]\color{byzantine}\bfseries,
			%keywords=[3]{int,string}, %types%
			%keywordstyle=[3]\color{caribbeangreen},
			keywords=[4]{effect,perform,continue,discontinue},
			keywordstyle=[4]\color{Bittersweet}\bfseries,
			classoffset=1,
			upquote=true,
			keywordstyle=\color{byzantine}\bfseries,
			classoffset=0,
			mathescape=true,
			numberstyle=\tiny\color{gray},
			numbersep=5pt
}

\lstnewenvironment{code}[1][]
    { % \centering
      \lstset{
				basicstyle=\ttfamily\footnotesize,
				#1}%
      \csname lst@setfirstlabel\endcsname}
    { %\centering
      \csname lst@savefirstlabel\endcsname}

\lstMakeShortInline[columns=fullflexible]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Semantics definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\olam}[2]{\lambda^o #1. #2}
\newcommand{\llambda}{\lambda\!\!\lambda}
\newcommand{\clam}[2]{\lambda^c #1. #2}
\newcommand{\lam}[2]{\Lambda #1. #2}

\newcommand{\env}{\epsilon}
\newcommand{\envext}[3]{#1[#2 \mapsto #3]}

\newcommand{\oclos}[3]{\llparenthesis \olam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\cclos}[3]{\llparenthesis \clam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\clos}[3]{\llparenthesis \lam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\kw}[1]{\text{\bf #1}}
\newcommand{\effval}[2]{\textsf{do} ~#1 ~#2}
\newcommand{\exnval}[1]{\textsf{exn} ~#1}

\newcommand{\handle}[2]{\kw{match} ~#1 ~\kw{with} ~#2}
\newcommand{\throw}[2]{\kw{raise} ~#1 ~#2}
\newcommand{\perform}[2]{\kw{perform} ~#1 ~#2}

\newcommand{\caseval}[2]{\kw{return}~#1 \mapsto #2}
\newcommand{\caseexn}[3]{\kw{exception} ~#1 ~#2 \mapsto #3}
\newcommand{\caseeff}[4]{\kw{effect} ~#1 ~#2 ~#3 \mapsto #4}

\newcommand{\farg}[2]{\langle #1 ~#2 \rangle_a}
\newcommand{\ffun}[1]{\langle #1 \rangle_f}
\newcommand{\faritha}[3]{\langle #1 ~#2 ~#3 \rangle_{b1}}
\newcommand{\farithb}[2]{\langle #1 ~#2 \rangle_{b2}}

\newcommand{\kcons}{\lhd}
\newcommand{\fiber}{\varphi}
\newcommand{\fl}{\psi} % Frame List
\newcommand{\hc}{\eta} % Handler Closure

\newcommand{\cstack}{\gamma} % C Stack
\newcommand{\ostack}{\omega} % OCaml Stack
\newcommand{\cstacka}[2]{\big \lceil #1, #2 \big \rceil_c} % C stack with arguments
\newcommand{\ostacka}[2]{\big \lceil #1, #2 \big \rceil_o} % OCaml stack with arguments
\newcommand{\ostackemp}{\bullet}
\newcommand{\stack}{\sigma}

\newcommand{\term}{\tau}
\newcommand{\config}{\mathfrak{C}}
\newcommand{\configa}[3]{\|#1,#2,#3\|}

\newcommand{\ostep}{\xrightarrow{o}}
\newcommand{\cstep}{\xrightarrow{c}}
\newcommand{\step}{\rightarrow}

\begin{document}

\title{Retrofitting Effect Handlers onto OCaml}

\begin{abstract}
	Effect handlers have gained immense interest in the recent years as a means
	for modular programming with user-defined effects. The runtime semantics of
	effect handlers is particularly attractive as they allow advanced control
	flow mechanisms such as first-class continuations, generators, async/await,
	coroutines to be composably expressed. In this paper, we present the design,
	a full-fledged implementation and evaluation of effect handlers for OCaml, an
	industrial-strength, multi-paradigm programming language. OCaml tends to be
	widely used for systems programming, and is compatible with program analysis
	tools that inspect the stack such as debuggers and profilers. Retrofitting
	effect handlers onto OCaml is challenging since OCaml does not have any
	non-local control flow mechanisms other than exceptions. Our implementation
	of effect handlers for OCaml imposes negligible overhead on code that does
	not use effect handlers, and remains compatible with program analysis tools
	that inspect the stack.
\end{abstract}

\maketitle

\section{Introduction}

Effect Handlers~\cite{Plotkin09} provide a modular foundation for user-defined
effects. The key idea is to separate the definition of the effectful
\emph{operations} from their interpretations, which are defined by
\emph{handlers} of the effects. For example,
%
\begin{lstlisting}
effect Read : in_channel -> string
\end{lstlisting}
%
declares an effect |Read|, which is parameterised with an input channel of type
|in_channel|, which when \emph{performed} returns a |string| value. A
computation can perform the |Read| effect without knowing how the |Read| effect
is implemented. This computation may be enclosed by different handlers that
interpret |Read| differently. For example, |Read| may be implemented by
performing a blocking read on the input channel or performing the read
asynchronously by offloading it to an event loop such as |libuv|. Thanks to the
separation of effectful operations from their interpretations, effect handlers
enable new approaches to modular programming. A computation may perform many
different effects, which are interpreted by one or more enclosing handlers.

\subsection{An effectful calculator}

What makes effect handlers quite powerful is that they provide a structured
form of delimited continuations~\cite{}, which enables advanced non-local
control-flow mechanisms such as resumable exceptions, coroutines, generators
and asynchronous I/O to be composably expressed. As an example, consider the
task of handling division-by-zero case in a calculator application. Different
calculators handle division-by-zero differently. In the iOS 13 Calculator App
(|iOS|), division-by-zero returns |Error|. In the Google search calculator App
(|gsearch|) |0/0| returns to |Error|, and for any other |n| not equal to |0|,
|n/0| returns |Infinity| with the same sign as |n|. How can we capture these
different behaviours without changing the evaluator?

Common Lisp Conditions~\cite{Conditions} are an elegant way to solve this
problem. Unlike exceptions where the library decides whether an error is fatal
or not, conditions allow the client of the library to make that decision. If
the error is non-fatal, Conditions provide a restart mechanism to
resume execution from the point where the condition was signalled. On
division-by-zero, the calculator signals the handler and lets the handler
decide the course of action based on the desired semantics. We can implement
this mechanism using effect handlers as shown below:

\begin{lstlisting}[numbers=left]
type sign = P | N
type val = Z of int | Error | Inf of sign
type exp = Val of val | ... | Div of exp*exp
effect DivBy0 : int -> val

let rec eval e =
	match e with
  | Val v -> v
	| ...
  | Div (e1,e2) ->
    match eval e1, eval e2 with
    | Z v1, Z v2 ->
        if v2 = 0 then perform (DivBy0 v1)
        else Z (v1/v2)
	  | Error, _ -> Error
		| Inf s, _ -> Inf s
  	| ...

let (/) n d = Div (Val (Z n), Val (Z d))
\end{lstlisting}

On line 4, we declare an effect |DivBy0| which is parameterised by an integer,
which when performed returns a value. While interpreting the division
expression, if the denominator is 0, then we perform |DivBy0| effect with the
numerator value (line 13) so that the context may decide whether the error is
fatal or not, and resume with an appropriate value if the error is not fatal.
We can get the |iOS| semantics by wrapping the evaluator computation with the
following handler:

\begin{lstlisting}
let ios e = match eval e with
| v -> v (* value case *)
| effect (DivBy0 _) k -> (* effect case *)
    continue k Error
\end{lstlisting}

If the evaluator returns a value, we simply return that. In case the evaluator
performs the |DivBy0| effect, we catch the effect in the effect case along with
the continuation |k| of the corresponding |perform| \emph{delimited} by this
handler. In the case of |iOS|, we |continue| the suspended computation with
|Error| value. Hence, the computation |ios(1/0)| returns |Error|. On the
other hand, we can get |gsearch| semantics by enclosing the evaluator in the
following handler:

\begin{lstlisting}
let gsearch e = match eval e with
| v -> v
| effect (DivBy0 v) k ->
  if v = 0 then continue k Error
	else if v > 0 then continue k (Inf P)
	else continue k (Inf N)
\end{lstlisting}

The computation |gsearch(1/0)| returns positive infinity (|Inf P|). We can
extend the calculator modularly with the ability to read user input using the
|Read| effect defined earlier as follows:

\begin{lstlisting}
type exp = ... | Inp
effect Read : in_channel -> string

let rec eval e = match e with
| ...
| Inp -> int_of_string(perform(Read stdin))
\end{lstlisting}

The |Read| effect can then be handled by another handler:

\begin{lstlisting}
let run e = match gsearch e with
| v -> v
| effect (Read chan) k ->
	register_async_input_line (chan, k);
	let ui = get_ui_k () in
	continue ui ()
\end{lstlisting}

\noindent which registers the read operation to be performed asynchronously
with the continuation as the callback. Subsequently, it resumes the
user-interface continuation so that the application remains responsive. Observe
that neither of the handlers needs to be aware of the other.

\subsection{Retrofitting effect handlers}
\label{sec:req}

There are many research languages and libraries built around effect
handlers~\cite{Koka,Links,Pyro,Frank,Eff}. Unlike these efforts, our goal is to
retrofit effect handlers onto the OCaml programming language, which has been in
continuous use for the past 25 years in large codebases including verification
tools~\cite{FStar,Coq}, mission critical software systems~\cite{astree} and
latency sensitive networked applications~\cite{JS,Docker,MirageOS}. OCaml is
particularly favoured for its competitive yet predictable performance, with fast
foreign-function interface (FFI) and excellent compatibility with program
analysis tools such as debuggers and profilers that utilise DWARF stack unwind
tables to obtain a backtrace. Our primary motivation for adding effect handlers
to OCaml is to support (1) highly concurrent applications such as web servers to
be expressed naturally in \emph{direct-style} as opposed to using callbacks and
(2) efficient data and task parallel programs in the vein of OpenMP~\cite{} and
Intel TBB~\cite{}.

OCaml, however, does not support any non-local control flow mechanisms other
than exceptions. This makes it particularly challenging to implement the
delimited continuations necessary for effect handlers without sacrificing the
desirable properties of OCaml. One standard way of implementing continuations is
to use continuation-passing style (CPS) in the compiler's intermediate
representation (IR)~\cite{Koka}. If the compiler were to use CPS, then reifying
continuations in the source language is relatively straight-forward. But OCaml
does not use CPS IR, and changing the OCaml compiler to utilise CPS IR would be
an enormous undertaking. CPS IR would also affect the performance profile of
OCaml applications due to increased memory allocations as continuation closures
get allocated on the heap~\cite{Folklore}. Moreover, with CPS, stack unwinding
is meaningless and hence, we would lose compatibility with tools that inspect
the program stack. Hence, we choose not to CPS translation.

The alternative is to use the call stack for implementing continuation.
Farvardin et al~\cite{Folklore} show that there is a spectrum of implementation
strategies for continuation with different trade-offs. We motivate our
implementation strategy based on the following ideal requirements:

\begin{enumerate}[label=R\arabic*]
	\item \textbf{Backwards compatibility} A well behaved OCaml program does not
		break under OCaml extended with effect handlers. OCaml code that does not
		use effect handlers will pay negligible performance cost.
	\item \textbf{Tool compatibility} OCaml with effect handlers produce
		well-formed backtraces, and remains compatible with program analysis tools
		such as debuggers and profilers that inspect the stack using DWARF unwind
		tables.
	\item \textbf{Effect handler efficiency} In order to support
		highly-concurrent applications, the program must accommodate millions of
		continuations in the heap. Installing effect handlers, capturing and
		resuming continuations must be fast.
	\item \textbf{Effect handler expressivity} While making continuations
		resumable at-most once (\emph{affine}) is a standard way to make
		continuation capture fast, we must still support use cases where the
		continuations are resumed more than once.
\end{enumerate}

The need to host millions of active continuations in the heap rules out the use
of large contiguous stack space for continuations as in C. Instead, we resort
to using small initial stacks and growing the stacks on demand. As a result,
OCaml functions, irrespective of whether they use effect handlers, need to
perform stack overflow checks and external C functions, which do not have stack
overflow checks, must be performed on a separate stack. Additionally, we must
generate DWARF stack unwind tables for stacks that may be non-contiguous and
contain frames from different languages. In this work, we develop the compiler
and runtime support for implementing efficient effect handlers for OCaml.

Our work is also timely. WebAssembly~\ref{} community group is actively
considering effect handlers as one of the mechanism for supporting concurrency,
asynchronous I/O and generators~\ref{WasmPropoal}. Project Loom~\cite{} is an
OpenJDK project which adds virtual threads and delimited continuations to Java.
We believe that our design choices will inform similar choices to be made in
the other languages.

The search for an expressive effect system that guarantees that all the effects
performed in the program are handled (\emph{effect safety}) in the presence of
advanced features such as polymorphism, modularity and generativity is an
active area of research~\cite{Leijen14, Biernacki19, Biernacki20,
Hillerstrom20}. We do not focus on this question in this paper, and our
implementation of effect handlers in OCaml does not guarantee effect safety.
For example, running |perform (Read stdin)| without an enclosing handler raises
exception |Unhandled|. We leave the question of effect safety for future work.

\subsection{Contributions}

Our contributions are to present:

\begin{itemize}
	\item the design and implementation of affine effect handlers for OCaml with
		negligible performance impact on code that does not use effect handlers.
		Our design lets us retain OCaml's compatibility with program analysis tools
		that inspect the stack.
	\item a formal operation semantics for the effect handler implementation in
		OCaml.
	\item extensive evaluation which shows that our implementation has negligible
		impact on code that does not use effect handlers, and serves as an
		efficient foundation for scalable concurrent and parallel programming.
\end{itemize}

We have implemented effect handlers in a multicore extension of the OCaml
programming language. We call our implementation ``Multicore OCaml'' to
distinguish it from stock OCaml. Multicore OCaml uses effect handlers as the
mechanism to express user-level concurrency.

The rest of the paper is organized as follows. We describe the details of the
OCaml program stack in the next section, and highlight the features that the
effect handler implementation must retain in order to provide backwards
compatibility. In \S\ref{sec:handlers}, we motivate the design choice that we
have made for effect handlers in Multicore OCaml with the help of examples.
\S\ref{sec:semantics} presents the formal operational semantics for Multicore
OCaml effect handlers. \S\ref{sec:impl} discusses the compiler and the runtime
system support for implementing effect handlers. \S\ref{sec:eval} presents
extensive performance evaluation of effect handlers against the goals set in
\S\ref{sec:req}. \S\ref{sec:related} and \S\ref{sec:conc} present the related
work and the conclusions.

\section{Background: OCaml Stacks}
\label{sec:stack}

\section{Handlers by example}
\label{sec:handlers}

\section{Semantics}
\label{sec:semantics}

The initial configuration for an expression $e$ is
$\configa{e}{\emptyset}{\cstacka{[]}{\bullet}}$. We define {\sf continue} and
{\sf discontinue} as follows:

\begin{smathpar}
	\begin{array}{rcl}
		\textsf{continue} ~k ~e & = & k ~(\olam{x}{x}) ~e \\
		\textsf{discontinue} ~k ~l ~e & = & k ~(\olam{x}{\throw{l}{x}}) ~e
	\end{array}
\end{smathpar}

\begin{figure*}
	\begin{minipage}[t]{0.49\linewidth}
	\begin{smathpar}
	\begin{array}{rrcl}
		\text{Constants} & n & \coloneqq & ℤ \\
		\text{Abstractions} & \Lambda & \coloneqq & \lambda^o \mid \lambda^c \\
		\text{Expressions} & e & \coloneqq & n \mid x \mid e ~e \mid  \lam{x}{e} \mid e \odot e \mid \throw{l}{e} \\
											 &   & \mid      & \handle{e}{h} \mid \perform{l}{e} \\
		\text{Handlers} & h & \coloneqq & \{\caseval{x}{e}\} \mid \{\caseexn{l}{x}{e}\} \uplus h \\
		               &   & \mid & \{\caseeff{l}{x}{k}{e}\} \uplus h \\
		\text{Values} & v & \coloneqq & n \mid k \mid \clos{x}{e}{\env} \mid \effval{l}{k} \mid \exnval{l} \\
		\text{Frames} & r & \coloneqq & \farg{e}{\env} \mid \ffun{v} \mid \faritha{\odot}{e}{\env} \mid \farithb{\odot}{ℕ} \\
		\text{Environments} & \env & \coloneqq & \emptyset \mid \envext{\env}{x}{v} \\
	\end{array}
	\end{smathpar}
	\end{minipage}
	\begin{minipage}[t]{0.49\linewidth}
	\begin{smathpar}
	\begin{array}{rrcl}
		\text{Handler Closures} & \hc & \coloneqq & (h,\env) \\
		\text{Frame List} & \fl & \coloneqq & [] \mid r :: \fl \\
		\text{Fibers} & \fiber & \coloneqq & (\fl, \hc) \\
		\text{Continuations} & k & \coloneqq & [] \mid \fiber \lhd k \\
		\text{C stacks} & \cstack & \coloneqq & \cstacka{\fl}{\ostack}\\
		\text{OCaml stacks} & \ostack & \coloneqq & \ostacka{k}{\cstack} \mid \ostackemp \\
		\text{Stacks} & \stack & \coloneqq & \cstack \mid \ostack \\
		\text{Terms} & \term & \coloneqq & e \mid v \\
		\text{Configurations} & \config & \coloneqq & \configa{\tau}{\env}{\stack}
	\end{array}
	\end{smathpar}
	\end{minipage}
	\caption{Term Syntax}
	\label{sem:syntax}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcl}
			\textsc{Var}     & (x,\env, \fl) & \rightsquigarrow
			                 & (\env(x), \env, \fl) \\
			\textsc{Arith1}  & (e_1 \odot e_2, \env, \fl) & \rightsquigarrow
			                 & (e_1,\env, \faritha{\odot}{e_2}{\env}::\fl) \\
			\textsc{Arith2}  & (n_1, \_, \faritha{\odot}{e_2}{\env}::\fl) & \rightsquigarrow
			                 & (e_2, \env, \farithb{\odot}{n_1}::\fl) \\
			\textsc{Arith3}  & (n_2, \env, \farithb{\odot}{n_1}::\fl) & \rightsquigarrow
			                 & (\llbracket n_1 \odot n_2 \rrbracket, \env, \fl) \\
			\textsc{App1}    & (e_1 ~e_2, \env, \fl) & \rightsquigarrow
			                 & (e_1, \env, \farg{e_2}{\env}::\fl) \\
			\textsc{App2}    & (\lam{x}{e}, \env, \fl) & \rightsquigarrow
			                 & (\clos{x}{e}{\env}, \env, \fl) \\
			\textsc{App3}    & (\clos{x}{e_1}{\env_1}, \_, \farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_2, \env_2, \ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
			\textsc{Resume1} & (k,\_,\farg{e_1}{\env_1}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_1, \env_1, \ffun{k}::\farg{e_2}{\env_2}::\fl) \\
			\textsc{Resume2} & (\clos{x}{e_1}{\env_1}, \_, \ffun{k}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_2, \env_2, \ffun{k}::\ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
			\textsc{Perform} & (\perform{l}{e}, \env, \fl) & \rightsquigarrow
			                 & (e, \env, \ffun{\effval{l}{[[],(\{\caseval{x}{x}\},\emptyset)]}}::\fl) \\
			\textsc{Raise}   & (\throw{l}{e}, \env, \fl) & \rightsquigarrow
											 & (e, \env, \ffun{\exnval{l}}::\fl)
		\end{array}
	\end{smathpar}
	\caption{Local Reductions -- $(\term, \env, \fl) \rightsquigarrow (\tau, \env, \fl)$.}
	\label{sem:step}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcll}
			\textsc{LocalO}   & (\term,\env,(\fl,\hc) \kcons k,\cstack) & \ostep
												& \configa{\term'}{\env'}{\ostacka{(\fl',\hc) \kcons k}{\cstack}}
												& \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
			\textsc{RetC}   & (v, \_, [([],(h,\env))], \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\cstack}
												& \text{if } \{\caseval{x}{e}\} \in h \\
			\textsc{RetFib} & (v, \_, ([],(h,\env)) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstack}}
												& \text{if } \{\caseval{x}{e}\} \in h \\
			\textsc{CallO}    & (v, \_, (\oclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{(\fl,\hc) \kcons k}{\cstack}} \\
			\textsc{ExtCall}  & (v, \_, (\cclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\cstacka{[]}{\ostacka{(\fl,\hc) \kcons k}{\cstack}}} \\
			\textsc{Resume}   & (v, \_, (\ffun{k}::\ffun{\oclos{x}{e}{\env}}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k ~@~ (\fl,\hc) \kcons k'}{\cstack}} \\
			\textsc{Handle}   & (\handle{e}{h}, \env, k, \cstack) & \ostep
												& \configa{e}{\env}{\ostacka{([],(h,\env)) \kcons k}{\cstack}} \\
			\textsc{EffUnHn}  & (v, \_, [\ffun{\effval{l}{k}}::\fl,(h,\env)], \cstack) & \ostep
												& \configa{e}{\emptyset}{\ostacka{k ~@~ [(\fl,(h,\env))]}{\cstack}}
												& \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
									& & & & \text{and } {e = \throw{\textsf{unhandled}}{0}} \\
			\textsc{EffHn}    & (v, \_, (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons k', \cstack) & \ostep
												& \configa{e}{\env[r \mapsto k''][x \mapsto v]}{\ostacka{k'}{\cstack}}
												& \text{if } \{\caseeff{l}{x}{r}{e}\} \in h \\
									& & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
			\textsc{EffFwd}   & (v, \env', (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
												& \configa{v}{\env'}{\ostacka{(\ffun{\effval{l}{k''}}::\fl',\hc') \kcons k'}{\cstack}}
												& \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
								  & & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
			\textsc{ExFwdC}   & (v, \env, [\ffun{\exnval{l}}::\_,(h,\_)], \cstacka{\fl'}{\ostack}) & \ostep
												& \configa{v}{\env}{\cstacka{\ffun{\exnval{l}}::\fl'}{\ostack}}
												& \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
			\textsc{ExHn}     & (v, \_, (\ffun{\exnval{l}}::\_,(h,\env)) \kcons k', \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k'}{\cstack}}
												& \text{if } \{\caseexn{l}{x}{e}\} \in h \\
			\textsc{ExFwdFib} & (v, \env, (\ffun{\exnval{l}}::\_,(h,\_)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
												& \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl',\hc') \kcons k'}{\cstack}}
												& \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
		\end{array}
	\end{smathpar}
	\caption{OCaml Reductions -- $(\term, \env, k, \cstack) \ostep \config$.}
	\label{sem:ostep}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcll}
			\textsc{LocalC}   & (\term,\env,\fl,\ostack) & \cstep
												& \configa{\term'}{\env'}{\cstacka{\fl'}{\ostack}}
												& \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
			\textsc{RetToO}   & (v,\env,[],\ostacka{k}{\cstack}) & \cstep
			                  & \configa{v}{\env}{\ostacka{k}{\cstack}} \\
			\textsc{CallC}    & (v, \_, \cclos{x}{e}{\env}::\fl, \ostack) & \cstep
												& \configa{e}{\envext{\env}{x}{v}}{\cstacka{\fl}{\ostack}} \\
			\textsc{Callback} & (v, \_, \oclos{x}{e}{\env}::\fl, \ostack) & \cstep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstacka{\fl}{\ostack}}}
												& \text{if } k = [[],(\{\caseval{x}{x}\},\emptyset)] \\
			\textsc{ExnFwdO}  & (v, \env, \ffun{\exnval{l}}::\_, \ostacka{(\fl,\hc) \kcons k}{\cstack}) & \cstep
												& \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl,\hc) \kcons k}{\cstack}}
		\end{array}
	\end{smathpar}
	\caption{C Reductions -- $(\term, \env, \fl, \ostack) \cstep \config$.}
	\label{sem:cstep}
\end{figure*}

\begin{figure*}
	\begin{mathpar}
		\begin{array}{rc}

			\textsc{StepC} & \inferrule
			                    {(\term, \env, \fl, \ostack) \cstep \config}
													{\configa{\term}{\env}{\cstacka{\fl}{\ostack}} \step \config} \\ \\
			\textsc{StepO} & \inferrule
													{(\term, \env, k, \cstack) \ostep \config}
													{\configa{\term}{\env}{\ostacka{k}{\cstack}} \step \config}
		\end{array}
	\end{mathpar}
	\caption{Top-level Reductions -- $\config \step \config$.}
	\label{sem:top}
\end{figure*}

\section{Implementation}
\label{sec:impl}

\section{Evaluation}
\label{sec:eval}

\section{Related Work}
\label{sec:related}

\section{Conclusions and Future Work}
\label{sec:conc}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}


\end{document}
