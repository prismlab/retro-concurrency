\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Custom definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{balance}
%\usepackage{url}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{multirow}
\usepackage{microtype}
\usepackage{soul,xcolor}
\usepackage{mathpartir}
\usepackage{amsmath,amsthm}
\usepackage[utf8]{inputenc}
\input{unicode-preamble.tex}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes}
\usepackage{stmaryrd}

\crefformat{section}{ยง#2#1#3}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{nop}{}{}
\newenvironment{smathpar}{
\begin{nop}\small\begin{mathpar}}{
\end{mathpar}\end{nop}\ignorespacesafterend}

\newcommand{\kc}[1]{{\color{red} {\it [KC says: #1]}}}
\newcommand{\am}[1]{{\color{blue} {\it [AM says: #1]}}}

\definecolor{Bittersweet}{rgb}{1.0, 0.44, 0.37}
\definecolor{MidnightBlue}{rgb}{0.0, 0.2, 0.4}
\definecolor{BrightBlue}{rgb}{0.0, 0.2, 0.7}
\definecolor{byzantine}{rgb}{0.74, 0.2, 0.64}
\definecolor{caribbeangreen}{rgb}{0.0, 0.8, 0.6}

\lstset{
			language=caml,
      basicstyle=\ttfamily\footnotesize,
      flexiblecolumns=false,
			tabsize=2,
			escapechar={<@}{@>},
      %basewidth={0.5em,0.45em},
      %aboveskip={3pt},
      %belowskip={3pt},
			breaklines = true,
      breakatwhitespace = true,
      keywordstyle=\color{Bittersweet}\bfseries,
      commentstyle=\color{blue}\itshape,
      stringstyle=\color{MidnightBlue},
			keywords=[2]{},
			keywordstyle=[2]\color{byzantine}\bfseries,
			keywords=[3]{effect,perform,continue,discontinue,clone_continuation},
			keywordstyle=[3]\color{caribbeangreen}\bfseries,
			keywords=[4]{call,return,external},
			keywordstyle=[4]\color{Bittersweet}\bfseries,
			classoffset=1,
			upquote=true,
			keywordstyle=\color{byzantine}\bfseries,
			classoffset=0,
			mathescape=true,
			numberstyle=\tiny\color{gray},
			numbersep=5pt
}

\lstnewenvironment{code}[1][]
    { % \centering
      \lstset{
				basicstyle=\ttfamily\footnotesize,
				#1}%
      \csname lst@setfirstlabel\endcsname}
    { %\centering
      \csname lst@savefirstlabel\endcsname}

\lstMakeShortInline[columns=fullflexible]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Semantics definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\olam}[2]{\lambda^o #1. #2}
\newcommand{\llambda}{\lambda\!\!\lambda}
\newcommand{\clam}[2]{\lambda^c #1. #2}
\newcommand{\lam}[2]{\Lambda #1. #2}

\newcommand{\env}{\epsilon}
\newcommand{\envext}[3]{#1[#2 \mapsto #3]}

\newcommand{\oclos}[3]{\llparenthesis \olam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\cclos}[3]{\llparenthesis \clam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\clos}[3]{\llparenthesis \lam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\kw}[1]{\text{\bf #1}}
\newcommand{\effval}[2]{\textsf{do} ~#1 ~#2}
\newcommand{\exnval}[1]{\textsf{exn} ~#1}

\newcommand{\handle}[2]{\kw{match} ~#1 ~\kw{with} ~#2}
\newcommand{\throw}[2]{\kw{raise} ~#1 ~#2}
\newcommand{\perform}[2]{\kw{perform} ~#1 ~#2}

\newcommand{\caseval}[2]{\kw{return}~#1 \mapsto #2}
\newcommand{\caseexn}[3]{\kw{exception} ~#1 ~#2 \mapsto #3}
\newcommand{\caseeff}[4]{\kw{effect} ~#1 ~#2 ~#3 \mapsto #4}

\newcommand{\farg}[2]{\langle #1 ~#2 \rangle_a}
\newcommand{\ffun}[1]{\langle #1 \rangle_f}
\newcommand{\faritha}[3]{\langle #1 ~#2 ~#3 \rangle_{b1}}
\newcommand{\farithb}[2]{\langle #1 ~#2 \rangle_{b2}}

\newcommand{\kcons}{\lhd}
\newcommand{\fiber}{\varphi}
\newcommand{\fl}{\psi} % Frame List
\newcommand{\hc}{\eta} % Handler Closure

\newcommand{\cstack}{\gamma} % C Stack
\newcommand{\ostack}{\omega} % OCaml Stack
\newcommand{\cstacka}[2]{\big \lceil #1, #2 \big \rceil_c} % C stack with arguments
\newcommand{\ostacka}[2]{\big \lceil #1, #2 \big \rceil_o} % OCaml stack with arguments
\newcommand{\ostackemp}{\bullet}
\newcommand{\stack}{\sigma}

\newcommand{\term}{\tau}
\newcommand{\config}{\mathfrak{C}}
\newcommand{\configa}[3]{\|#1,#2,#3\|}

\newcommand{\ostep}{\xrightarrow{o}}
\newcommand{\cstep}{\xrightarrow{c}}
\newcommand{\step}{\rightarrow}

\begin{document}

\title{Retrofitting Effect Handlers onto OCaml}

\begin{abstract}
	Effect handlers have gained immense interest in the recent years as a means
	for modular programming with user-defined effects. The runtime semantics of
	effect handlers is particularly attractive as they allow advanced control
	flow mechanisms such as first-class continuations, generators, async/await,
	coroutines to be composably expressed. In this paper, we present the design,
	a full-fledged implementation and evaluation of effect handlers for OCaml, an
	industrial-strength, multi-paradigm programming language. OCaml tends to be
	widely used for systems programming, and is compatible with program analysis
	tools that inspect the stack such as debuggers and profilers. Retrofitting
	effect handlers onto OCaml is challenging since OCaml does not have any
	non-local control flow mechanisms other than exceptions. Our implementation
	of effect handlers for OCaml imposes negligible overhead on code that does
	not use effect handlers, and remains compatible with program analysis tools
	that inspect the stack.
\end{abstract}

\maketitle

\section{Introduction}

Effect Handlers~\cite{Plotkin09} provide a modular foundation for user-defined
effects. The key idea is to separate the definition of the effectful
\emph{operations} from their interpretations, which are defined by
\emph{handlers} of the effects. For example,
%
\begin{lstlisting}
effect Read : in_channel -> string
\end{lstlisting}
%
declares an effect |Read|, which is parameterised with an input channel of type
|in_channel|, which when \emph{performed} returns a |string| value. A
computation can perform the |Read| effect without knowing how the |Read| effect
is implemented. This computation may be enclosed by different handlers that
interpret |Read| differently. For example, |Read| may be implemented by
performing a blocking read on the input channel or performing the read
asynchronously by offloading it to an event loop such as |libuv|. Thanks to the
separation of effectful operations from their interpretations, effect handlers
enable new approaches to modular programming. A computation may perform many
different effects, which are interpreted by one or more enclosing handlers.

\subsection{An effectful calculator}

What makes effect handlers quite powerful is that they provide a structured
form of delimited continuations~\cite{}, which enables advanced non-local
control-flow mechanisms such as resumable exceptions, coroutines, generators
and asynchronous I/O to be composably expressed. As an example, consider the
task of handling division-by-zero case in a calculator application. Different
calculators handle division-by-zero differently. In the iOS 13 Calculator App
(|iOS|), division-by-zero returns |Error|. In the Google search calculator App
(|gsearch|) |0/0| returns to |Error|, and for any other |n| not equal to |0|,
|n/0| returns |Infinity| with the same sign as |n|. How can we capture these
different behaviours without changing the evaluator?

Common Lisp Conditions~\cite{Conditions} are an elegant way to solve this
problem. Unlike exceptions where the library decides whether an error is fatal
or not, conditions allow the client of the library to make that decision. If
the error is non-fatal, Conditions provide a restart mechanism to
resume execution from the point where the condition was signalled. On
division-by-zero, the calculator signals the handler and lets the handler
decide the course of action based on the desired semantics. We can implement
this mechanism using effect handlers as shown below:

\begin{lstlisting}[numbers=left]
type sign = P | N
type val = Z of int | Error | Inf of sign
type exp = Val of val | ... | Div of exp*exp
effect DivBy0 : int -> val

let rec eval e =
	match e with
  | Val v -> v
	| ...
  | Div (e1,e2) ->
    match eval e1, eval e2 with
    | Z v1, Z v2 ->
        if v2 = 0 then perform (DivBy0 v1)
        else Z (v1/v2)
	  | Error, _ -> Error
		| Inf s, _ -> Inf s
  	| ...

let (/) n d = Div (Val (Z n), Val (Z d))
\end{lstlisting}

On line 4, we declare an effect |DivBy0| which is parameterised by an integer,
which when performed returns a value. While interpreting the division
expression, if the denominator is 0, then we perform |DivBy0| effect with the
numerator value (line 13) so that the context may decide whether the error is
fatal or not, and resume with an appropriate value if the error is not fatal.
We can get the |iOS| semantics by wrapping the evaluator computation with the
following handler:

\begin{lstlisting}
let ios e = match eval e with
| v -> v (* value case *)
| effect (DivBy0 _) k -> (* effect case *)
    continue k Error
\end{lstlisting}

If the evaluator returns a value, we simply return that. In case the evaluator
performs the |DivBy0| effect, we catch the effect in the effect case along with
the continuation |k| of the corresponding |perform| \emph{delimited} by this
handler. In the case of |iOS|, we |continue| the suspended computation with
|Error| value. Hence, the computation |ios(1/0)| returns |Error|. On the
other hand, we can get |gsearch| semantics by enclosing the evaluator in the
following handler:

\begin{lstlisting}
let gsearch e = match eval e with
| v -> v
| effect (DivBy0 v) k ->
  if v = 0 then continue k Error
	else if v > 0 then continue k (Inf P)
	else continue k (Inf N)
\end{lstlisting}

The computation |gsearch(1/0)| returns positive infinity (|Inf P|).

\subsection{Asynchronous I/O}
\label{sec:aio}

We can extend the calculator modularly with the ability to read user input
using the |Read| effect defined earlier as follows:

\begin{lstlisting}
type exp = ... | Inp
effect Read : in_channel -> string

let rec eval e = match e with
| ...
| Inp -> int_of_string(perform(Read stdin))
\end{lstlisting}

The |Read| effect can then be handled by another handler enclosing the
division-by-zero handler:

\begin{lstlisting}
let run e = match gsearch e with
| v -> v
| effect (Read chan) k ->
	register_async_input_line (chan, k);
	let ui = get_ui_k () in
	continue ui ()
\end{lstlisting}

\noindent which registers the read operation to be performed asynchronously
with the continuation as the callback. Subsequently, it resumes the
user-interface continuation so that the application remains responsive. Observe
that neither of the handlers needs to be aware of the other.

\subsection{Retrofitting effect handlers}
\label{sec:req}

There are many research languages and libraries built around effect
handlers~\cite{Koka,Links,Pyro,Frank,Eff}. Unlike these efforts, our goal is to
retrofit effect handlers onto the OCaml programming language, which has been in
continuous use for the past 25 years in large codebases including verification
tools~\cite{FStar,Coq}, mission critical software systems~\cite{astree} and
latency sensitive networked applications~\cite{JS,Docker,MirageOS}. OCaml is
particularly favoured for its competitive yet predictable performance, with
fast foreign-function interface (FFI) and excellent compatibility with program
analysis tools such as debuggers and profilers that utilise DWARF stack unwind
tables to obtain a backtrace. Our primary motivation for adding effect handlers
to OCaml is to support (1) highly concurrent applications such as web servers
to be expressed naturally in \emph{direct-style} as opposed to using callbacks
and (2) efficient data and task parallel programs in the vein of Cilk~\cite{},
OpenMP~\cite{} and Intel TBB~\cite{}.

OCaml, however, does not support any non-local control flow mechanisms other
than exceptions. This makes it particularly challenging to implement the
delimited continuations necessary for effect handlers without sacrificing the
desirable properties of OCaml. One standard way of implementing continuations
is to use continuation-passing style (CPS) in the compiler's intermediate
representation (IR)~\cite{Koka}. If the compiler were to use CPS, then reifying
continuations in the source language is relatively straight-forward. But OCaml
does not use CPS IR, and changing the OCaml compiler to utilise CPS IR would be
an enormous undertaking. CPS IR would also affect the performance profile of
OCaml applications due to increased memory allocations as continuation closures
get allocated on the heap~\cite{Folklore}. Moreover, with CPS, stack unwinding
is meaningless and hence, we would lose compatibility with tools that inspect
the program stack. Hence, we choose not to CPS translation. The alternative is
to use the call stack for implementing continuation. Farvardin et
al~\cite{Folklore} show that there is a spectrum of implementation strategies
for continuation with different trade-offs.

The search for an expressive effect system that guarantees that all the effects
performed in the program are handled (\emph{effect safety}) in the presence of
advanced features such as polymorphism, modularity and generativity is an
active area of research~\cite{Leijen14, Biernacki19, Biernacki20,
Hillerstrom20}. We do not focus on this question in this paper, and our
implementation of effect handlers in OCaml does not guarantee effect safety.
For example, running |perform (Read stdin)| without an enclosing handler raises
exception |Unhandled| at the point of |perform|. We leave the question of
effect safety for future work.

\subsection{Requirements}
\label{sec:requirements}

We motivate our implementation strategy based on the following ideal
requirements:

\begin{enumerate}[label=R\arabic*]
	\item \textbf{Backwards compatibility} A well behaved OCaml program does not
		break under OCaml extended with effect handlers. OCaml code that does not
		use effect handlers will pay negligible performance cost.
	\item \textbf{Tool compatibility} OCaml with effect handlers produce
		well-formed backtraces, and remains compatible with program analysis tools
		such as debuggers and profilers that inspect the stack using DWARF unwind
		tables.
	\item \textbf{Effect handler efficiency} In order to support
		highly-concurrent applications, the program must accommodate millions of
		continuations in the heap. Installing effect handlers, capturing and
		resuming continuations must be fast.
\if{0}
	\item \textbf{Effect handler expressivity} While making continuations
		resumable at-most once (\emph{affine}) is a standard way to make
		continuation capture fast, we must still support use cases where the
		continuations are resumed more than once.
\fi
	\item \textbf{Forwards compatibility} While this work does not present an
		effect system, the design must be compatible with a future effect system
		for OCaml. As a cornerstone of modularity, we also want blocking I/O code
		to \emph{transparently} be made asynchronous with the help of effect
		handlers.
\end{enumerate}

The need to host millions of active continuations in the heap rules out the use
of large contiguous stack space as in C for continuations. Instead, we resort
to using small initial stacks and growing the stacks on demand. As a result,
OCaml functions, irrespective of whether they use effect handlers, need to
perform stack overflow checks and external C functions, which do not have stack
overflow checks, must be performed on a separate stack. Additionally, we must
generate DWARF stack unwind tables for stacks that may be non-contiguous and
contain frames from different languages. In this work, we develop the compiler
and runtime support for implementing efficient effect handlers for OCaml.

Our work is also timely. WebAssembly~\ref{} community group is actively
considering effect handlers as one of the mechanism for supporting concurrency,
asynchronous I/O and generators~\ref{WasmPropoal}. Project Loom~\cite{} is an
OpenJDK project which adds virtual threads and delimited continuations to Java.
We believe that our design choices will inform similar choices to be made in
the other languages.

\subsection{Contributions}

Our contributions are to present:

\begin{itemize}
	\item the design and implementation of affine effect handlers for OCaml. Our
		design retains OCaml's compatibility with program analysis tools that
		inspect the stack using DWARF unwind tables. We have validated our DWARF
		unwind tables using an automated validator tool~\cite{}.
	\item a formal operation semantics for the effect handler implementation in
		OCaml.
	\item extensive evaluation which shows that our implementation has negligible
		impact on code that does not use effect handlers, and serves as an
		efficient foundation for scalable concurrent and parallel programming.
\end{itemize}

We have implemented effect handlers in a multicore extension of the OCaml
programming language. We call our implementation ``Multicore OCaml'' to
distinguish it from stock OCaml. Multicore OCaml uses effect handlers as the
mechanism to express user-level concurrency.

The rest of the paper is organized as follows. We describe the details of the
OCaml program stack in the next section, and highlight the features that the
effect handler implementation must retain in order to provide backwards
compatibility. In \S\ref{sec:refine}, we refine the design further
focussing on the issues that come up when integrating effect handlers into a
mainstream language. \S\ref{sec:semantics} presents the formal operational
semantics for Multicore OCaml effect handlers. \S\ref{sec:impl} discusses the
compiler and the runtime system support for implementing effect handlers.
\S\ref{sec:eval} presents extensive performance evaluation of effect handlers
against the goals set in \S\ref{sec:req}. \S\ref{sec:related} and
\S\ref{sec:conc} present the related work and the conclusions.

\section{Background: OCaml Stacks}
\label{sec:stack}

\begin{figure*}
\begin{minipage}{0.59\linewidth}
	\begin{minipage}{\linewidth}
		\begin{lstlisting}[numbers=left]
external ocaml_to_c : unit -> int = "ocaml_to_c"
exception E1
exception E2

let c_to_ocaml () = raise E1
let _ = Callback.register "c_to_ocaml" c_to_ocaml

let omain () =
  try (* h1 *)
    try (* h2 *) ocaml_to_c () with E2 -> 0
  with E1 -> 42;;

let _ = assert (omain () = 42)
		\end{lstlisting}
    \subcaption{\texttt{meander.ml}}
    \label{code:meander_ml}
	\end{minipage}
	\begin{minipage}{\linewidth}
		\begin{lstlisting}[language=c,numbers=left]
#include <caml/mlvalues.h>
#include <caml/callback.h>

value ocaml_to_c (value unit) {
  caml_callback(*caml_named_value("c_to_ocaml"), Val_unit);
  return Val_int(0);
}
		\end{lstlisting}
    \subcaption{\texttt{meander.c}}
    \label{code:meander_c}
	\end{minipage}
\end{minipage}
	\begin{minipage}{0.39\linewidth}
    \centering
    \includegraphics[scale=0.46]{figures/stock_stack}
    \subcaption{Stack layout before raising exception.}
    \label{fig:stock_stack}
  \end{minipage}
	\caption{Program stack on stock OCaml.}
\end{figure*}

The main challenge in implementing effect handlers in Multicore OCaml is
managing the program stack. To this end, in this section, we provide an
overview of the program stack and related mechanisms for stock OCaml.

In order to illustrate the layout of the stock OCaml stack, consider the
program in Figures~\ref{code:meander_ml} and~\ref{code:meander_c}. The OCaml
main function |omain| installs two exception handlers |h1| and |h2| to handle
exceptions |E1| and |E2|. |omain| calls the external C function |ocaml_to_c|,
which in turn calls back into OCaml function |c_to_ocaml|, which raises the
exception |E1|. OCaml supports raising exceptions in C as well as throwing
exceptions across external calls. Hence, the exception |E1| gets caught in the
handler |h1|, and |omain| returns |42|. The layout of the stack in native code
backend just before raising the exception in |c_to_ocaml| is illustrated in
Figure~\ref{fig:stock_stack}. The stack grows downwards.

OCaml uses the hardware stack as C, and hence the program stack has alternating
sequences of C and OCaml frames. Unlike C, OCaml does not create pointers into
OCaml frames. OCaml uses the hardware support for |call| and |return|
instructions for function calls and returns. OCaml does not perform explicit
stack overflow checks in code, and, just like C, relies on the guard page at
the end of the stack region to detect stack overflow. Stack overflow is
detected by a memory fault, and |Stack_overflow| exception is raised to unwind
the stack.

\subsection{External calls and callbacks}

OCaml does not use the C calling convention. In particular, there are no
callee-saved registers in OCaml. On the |x86-64| backend, a register each is
pinned for the \emph{allocation pointer} into the minor heap used for bump
pointer allocation, and the |Caml_state|, a table of global variables used by
the runtime. These registers are chosen to be C callee saved registers. This
makes external calls extremely fast in OCaml. If the external function does not
allocate in the OCaml heap, then the external functions can be called directly,
and no bookkeeping is necessary. For external functions which allocate in the
OCaml heap, the cached allocation pointer is saved to a field in the
|Caml_state| before the external call, and loaded back on return. Similarly,
callbacks into OCaml are also cheap. Callbacks into OCaml involves loading the
arguments in the right registers and calling the OCaml function. OCaml
callbacks are relatively common as the garbage collector (GC) finalisation
functions are executed as OCaml callbacks.

\subsection{Exception handlers}

The lack of callee-saved registers also makes exception handling fast as there
are no callee-saved registers to be restored when the exception handler runs.
Hence, installing an exception handler simply pushes the program counter (pc)
of the handler and the current exception pointer (|exn_ptr| -- a field in
|Caml_state|). The exception pointer is also updated to be the current stack
pointer (|sp|). This creates a linked-list of exception handler frames on the
stack as shown in Figure~\ref{fig:stock_stack}. Raising an exception simply
sets |sp| to |exn_ptr|, loads the saved |exn_ptr|, and jumps to the |pc| of the
handler.

In order to forward exceptions across C frames, the C stub function
|caml_start_program|, which is the entry point for both the main OCaml code and
callbacks into OCaml, pushes an exception handler frame that forwards the
exception the innermost OCaml exception handler (|raised_exn_c| in
Figure~\ref{fig:stock_stack}), or prints a fatal error (|fatal_uncaught|) if
there are no enclosing handlers. Exceptions are so cheap in OCaml that it is
very common to use them for \emph{local} control flow.

\subsection{DWARF unwind tables}

OCaml also generates precise DWARF unwind information for OCaml, thanks to
which debuggers such as |gdb| and |lldb|, and profilers such as |perf| work
out-of-the-box. For example, for the program in Figures~\ref{code:meander_ml}
and~\ref{code:meander_c}, one could set a break point in |gdb| at
|caml_raise_exn| to get the following backtrace.

\begin{lstlisting}[language=c,basicstyle=\ttfamily\footnotesize]
% gdb ./meander.exe
(gdb) break caml_raise_exn
Breakpoint 1 at 0x3e5dc
(gdb) r
Starting program: meander.exe
Breakpoint 1, 0x925dc in caml_raise_exn ()
(gdb) bt
#0  0x925dc in caml_raise_exn ()
#1  0x6fd3e in camlMeander__c_to_ocaml_83 () at meander.ml:5
#2  0x925a4 in caml_start_program ()
#3  0x8a84a in caml_callback_exn (...) at callback.c:145
#4  caml_callback (...) at callback.c:199
#5  0x76e0a in ocaml_to_c (unit=1) at meander_.c:5
#6  0x6fd77 in camlMeander__omain_88 () at meander.ml:10
#7  0x6fe92 in camlMeander__entry () at meander.ml:14
#8  0x6f719 in caml_program ()
#9  0x925a4 in caml_start_program ()
#10 0x92e4c in caml_startup_common (...) at startup_nat.c:162
#11 0x92eab in caml_startup_exn (...) at startup_nat.c:167
#12 caml_startup (...) at startup_nat.c:172
#13 0x6f55c in main (...) at main.c:44
\end{lstlisting}

\noindent which corresponds to the stack layout in
Figure~\ref{fig:stock_stack}.

The same backtrace can also be obtained by using \emph{frame pointers} instead
of DWARF unwind tables. OCaml allows compiling code with frame pointers, but
they are not enabled by default. OCaml stack tends to be deep with small frames
due to the pervasive use of recursive functions, not all of which is
tail-recursive. Hence, the addition of frame pointers can significantly
increase the size of the
stack~\footnote{https://github.com/ocaml/ocaml/issues/5721\#issuecomment-472965549}.
Moreover, not using frame pointers saves two instructions in the function
prologue and epilogue, and makes an extra register (|rbp| on x86) available.

In summary, the design of effect handlers in OCaml must accommodate these
desirable properties of OCaml with respect to the program stack.

\section{Refining the design}
\label{sec:refine}

In this section, we refine the effect handler design for the OCaml use case.
The primary motivation for adding effect handlers to OCaml is to support
non-local control flow mechanism to implement asynchronous I/O in direct style,
generators and enable task parallelism. These use cases do not resume the
continuations more than once. Hence, our continuations are one-shot, and
resuming the continuation more than once raises |Invalid_argument _| exception.
It is well-known that one-shot continuations can be implemented
efficiently~\cite{Bruggeman96RepresentingControl}.

While OCaml permits throwing exceptions across C frames, we do not allow
effects to propagate across C frames as the C frames would become part of the
captured continuation. Managing C frames as part of the continuation is a
complex endeavour~\cite{Daan17Aplas}, and we find that the complexity budget
outweighs the relatively fewer mechanisms enabled by this addition in our
setting.

The interaction of non-local control flow with systems programming is quite
subtle~\cite{TFP17}. Consider the following function that uses blocking I/O
functions from the OCaml standard library to copy data from the input channel
|ic| to the output channel |oc|:

\begin{lstlisting}
let rec copy ic oc =
  try
    let l = input_line ic in
    output_string oc (l ^ "\n");
    copy ic oc
  with _ -> (close_in ic; close_out oc)
\end{lstlisting}

|input_line| raises |End_of_file| exception on reaching the end of input.
Although not apparent, the code is written in a defensive style to handle other
exceptional cases such as the channels being closed externally. Both
|input_line| and |output_string| raise |Sys_error| exception if the channel is
closed. This function cleanly closes the channels on exceptional cases;
|close_*| functions do nothing if the channel is already closed.

One of our goals(\S\ref{sec:requirements}) is to make this code transparently
asynchronous. We can define effects for performing the I/O operations:
\begin{lstlisting}
effect In_line : in_channel -> string
effect Out_str : out_channel -> string -> unit
\end{lstlisting}
\noindent and wrap them up in functions with the same signature as the one from
the standard library.
\begin{lstlisting}
let input_line ic = perform (In_line ic)
let output_string oc = perform (Out_str oc)
\end{lstlisting}

We can then use a top-level I/O handler similar to the introductory example
(\S\ref{sec:aio}) to discharge the I/O operations asynchronously. This handles
value return cases, but what about the exceptional cases |End_of_file| and
|Sys_error|? We introduce a |discontinue| primitive to resume a continuation by
raising an exception. In this example, on reaching the end of file, we would
discontinue the continuation of the |copy| function with |discontinue k End_of_file|,
which raises the exception at |input_line|, and the open channels
will be closed.

Program that use resources such as channels are usually written defensively
with the assumption that calling a function will return \emph{exactly once},
either normally or exceptionally. Since effect handlers in Multicore OCaml do
not ensure that all the effects are handled, if the function performs an effect
with no matching handler, then the function \emph{will not return at all}. To
remedy this, when such an effect bubbles up to the top-level, we discontinue
the continuation with |Unhandled| exception so that the exception handlers may
run and clean up the resources.

\if{0}
\subsection{Multi-shot continuations}

Though our primary goal is to enable non-local control flow mechanisms, effect
handlers have been gaining increasing attention for Bayesian machine learning
and probabilisitic programming~\cite{PyroJMLR,MooreEdward2Google}, which resume
the continuations more than once for performing inference over the
probabilistic program. To enable these use cases, we provide a
|clone_continuation| primitive that makes a copy of the given continuation.
Care must be taken when using multi-shot continuations as they do not mix well
with code that uses resources. With multi-shot continuations, a function
\emph{may return more than once}. Consider the code below:

\begin{lstlisting}
let foo m = ...;perform E; ...
let bar () =
  let m = malloc 64 in
	begin try foo m with _ -> () end;
	free m
let _ = match bar () with
| () -> ()
| effect E k ->
    let k' = clone_continuation k in
		continue k (); continue k' ()
\end{lstlisting}

The function |bar| expects |foo| to return exactly once, ignoring any exceptions. However,
due to continuation cloning, the function returns twice, leading to double-free
error.
\fi

\section{Semantics}
\label{sec:semantics}

The initial configuration for an expression $e$ is
$\configa{e}{\emptyset}{\cstacka{[]}{\bullet}}$. We define {\sf continue} and
{\sf discontinue} as follows:

\begin{smathpar}
	\begin{array}{rcl}
		\textsf{continue} ~k ~e & = & k ~(\olam{x}{x}) ~e \\
		\textsf{discontinue} ~k ~l ~e & = & k ~(\olam{x}{\throw{l}{x}}) ~e
	\end{array}
\end{smathpar}

\begin{figure*}
	\begin{minipage}[t]{0.49\linewidth}
	\begin{smathpar}
	\begin{array}{rrcl}
		\text{Constants} & n & \coloneqq & โค \\
		\text{Abstractions} & \Lambda & \coloneqq & \lambda^o \mid \lambda^c \\
		\text{Expressions} & e & \coloneqq & n \mid x \mid e ~e \mid  \lam{x}{e} \mid e \odot e \mid \throw{l}{e} \\
											 &   & \mid      & \handle{e}{h} \mid \perform{l}{e} \\
		\text{Handlers} & h & \coloneqq & \{\caseval{x}{e}\} \mid \{\caseexn{l}{x}{e}\} \uplus h \\
		               &   & \mid & \{\caseeff{l}{x}{k}{e}\} \uplus h \\
		\text{Values} & v & \coloneqq & n \mid k \mid \clos{x}{e}{\env} \mid \effval{l}{k} \mid \exnval{l} \\
		\text{Frames} & r & \coloneqq & \farg{e}{\env} \mid \ffun{v} \mid \faritha{\odot}{e}{\env} \mid \farithb{\odot}{โ} \\
		\text{Environments} & \env & \coloneqq & \emptyset \mid \envext{\env}{x}{v} \\
	\end{array}
	\end{smathpar}
	\end{minipage}
	\begin{minipage}[t]{0.49\linewidth}
	\begin{smathpar}
	\begin{array}{rrcl}
		\text{Handler Closures} & \hc & \coloneqq & (h,\env) \\
		\text{Frame List} & \fl & \coloneqq & [] \mid r :: \fl \\
		\text{Fibers} & \fiber & \coloneqq & (\fl, \hc) \\
		\text{Continuations} & k & \coloneqq & [] \mid \fiber \lhd k \\
		\text{C stacks} & \cstack & \coloneqq & \cstacka{\fl}{\ostack}\\
		\text{OCaml stacks} & \ostack & \coloneqq & \ostacka{k}{\cstack} \mid \ostackemp \\
		\text{Stacks} & \stack & \coloneqq & \cstack \mid \ostack \\
		\text{Terms} & \term & \coloneqq & e \mid v \\
		\text{Configurations} & \config & \coloneqq & \configa{\tau}{\env}{\stack}
	\end{array}
	\end{smathpar}
	\end{minipage}
	\caption{Term Syntax}
	\label{sem:syntax}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcl}
			\textsc{Var}     & (x,\env, \fl) & \rightsquigarrow
			                 & (\env(x), \env, \fl) \\
			\textsc{Arith1}  & (e_1 \odot e_2, \env, \fl) & \rightsquigarrow
			                 & (e_1,\env, \faritha{\odot}{e_2}{\env}::\fl) \\
			\textsc{Arith2}  & (n_1, \_, \faritha{\odot}{e_2}{\env}::\fl) & \rightsquigarrow
			                 & (e_2, \env, \farithb{\odot}{n_1}::\fl) \\
			\textsc{Arith3}  & (n_2, \env, \farithb{\odot}{n_1}::\fl) & \rightsquigarrow
			                 & (\llbracket n_1 \odot n_2 \rrbracket, \env, \fl) \\
			\textsc{App1}    & (e_1 ~e_2, \env, \fl) & \rightsquigarrow
			                 & (e_1, \env, \farg{e_2}{\env}::\fl) \\
			\textsc{App2}    & (\lam{x}{e}, \env, \fl) & \rightsquigarrow
			                 & (\clos{x}{e}{\env}, \env, \fl) \\
			\textsc{App3}    & (\clos{x}{e_1}{\env_1}, \_, \farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_2, \env_2, \ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
			\textsc{Resume1} & (k,\_,\farg{e_1}{\env_1}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_1, \env_1, \ffun{k}::\farg{e_2}{\env_2}::\fl) \\
			\textsc{Resume2} & (\clos{x}{e_1}{\env_1}, \_, \ffun{k}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
			                 & (e_2, \env_2, \ffun{k}::\ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
			\textsc{Perform} & (\perform{l}{e}, \env, \fl) & \rightsquigarrow
			                 & (e, \env, \ffun{\effval{l}{[[],(\{\caseval{x}{x}\},\emptyset)]}}::\fl) \\
			\textsc{Raise}   & (\throw{l}{e}, \env, \fl) & \rightsquigarrow
											 & (e, \env, \ffun{\exnval{l}}::\fl)
		\end{array}
	\end{smathpar}
	\caption{Local Reductions -- $(\term, \env, \fl) \rightsquigarrow (\tau, \env, \fl)$.}
	\label{sem:step}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcll}
			\textsc{LocalO}   & (\term,\env,(\fl,\hc) \kcons k,\cstack) & \ostep
												& \configa{\term'}{\env'}{\ostacka{(\fl',\hc) \kcons k}{\cstack}}
												& \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
			\textsc{RetC}   & (v, \_, [([],(h,\env))], \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\cstack}
												& \text{if } \{\caseval{x}{e}\} \in h \\
			\textsc{RetFib} & (v, \_, ([],(h,\env)) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstack}}
												& \text{if } \{\caseval{x}{e}\} \in h \\
			\textsc{CallO}    & (v, \_, (\oclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{(\fl,\hc) \kcons k}{\cstack}} \\
			\textsc{ExtCall}  & (v, \_, (\cclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\cstacka{[]}{\ostacka{(\fl,\hc) \kcons k}{\cstack}}} \\
			\textsc{Resume}   & (v, \_, (\ffun{k}::\ffun{\oclos{x}{e}{\env}}::\fl,\hc) \kcons k, \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k ~@~ (\fl,\hc) \kcons k'}{\cstack}} \\
			\textsc{Handle}   & (\handle{e}{h}, \env, k, \cstack) & \ostep
												& \configa{e}{\env}{\ostacka{([],(h,\env)) \kcons k}{\cstack}} \\
			\textsc{EffUnHn}  & (v, \_, [\ffun{\effval{l}{k}}::\fl,(h,\env)], \cstack) & \ostep
												& \configa{e}{\emptyset}{\ostacka{k ~@~ [(\fl,(h,\env))]}{\cstack}}
												& \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
									& & & & \text{and } {e = \throw{\textsf{unhandled}}{0}} \\
			\textsc{EffHn}    & (v, \_, (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons k', \cstack) & \ostep
												& \configa{e}{\env[r \mapsto k''][x \mapsto v]}{\ostacka{k'}{\cstack}}
												& \text{if } \{\caseeff{l}{x}{r}{e}\} \in h \\
									& & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
			\textsc{EffFwd}   & (v, \env', (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
												& \configa{v}{\env'}{\ostacka{(\ffun{\effval{l}{k''}}::\fl',\hc') \kcons k'}{\cstack}}
												& \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
								  & & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
			\textsc{ExFwdC}   & (v, \env, [\ffun{\exnval{l}}::\_,(h,\_)], \cstacka{\fl'}{\ostack}) & \ostep
												& \configa{v}{\env}{\cstacka{\ffun{\exnval{l}}::\fl'}{\ostack}}
												& \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
			\textsc{ExHn}     & (v, \_, (\ffun{\exnval{l}}::\_,(h,\env)) \kcons k', \cstack) & \ostep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k'}{\cstack}}
												& \text{if } \{\caseexn{l}{x}{e}\} \in h \\
			\textsc{ExFwdFib} & (v, \env, (\ffun{\exnval{l}}::\_,(h,\_)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
												& \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl',\hc') \kcons k'}{\cstack}}
												& \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
		\end{array}
	\end{smathpar}
	\caption{OCaml Reductions -- $(\term, \env, k, \cstack) \ostep \config$.}
	\label{sem:ostep}
\end{figure*}

\begin{figure*}
	\begin{smathpar}
		\begin{array}{rrcll}
			\textsc{LocalC}   & (\term,\env,\fl,\ostack) & \cstep
												& \configa{\term'}{\env'}{\cstacka{\fl'}{\ostack}}
												& \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
			\textsc{RetToO}   & (v,\env,[],\ostacka{k}{\cstack}) & \cstep
			                  & \configa{v}{\env}{\ostacka{k}{\cstack}} \\
			\textsc{CallC}    & (v, \_, \cclos{x}{e}{\env}::\fl, \ostack) & \cstep
												& \configa{e}{\envext{\env}{x}{v}}{\cstacka{\fl}{\ostack}} \\
			\textsc{Callback} & (v, \_, \oclos{x}{e}{\env}::\fl, \ostack) & \cstep
												& \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstacka{\fl}{\ostack}}}
												& \text{if } k = [[],(\{\caseval{x}{x}\},\emptyset)] \\
			\textsc{ExnFwdO}  & (v, \env, \ffun{\exnval{l}}::\_, \ostacka{(\fl,\hc) \kcons k}{\cstack}) & \cstep
												& \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl,\hc) \kcons k}{\cstack}}
		\end{array}
	\end{smathpar}
	\caption{C Reductions -- $(\term, \env, \fl, \ostack) \cstep \config$.}
	\label{sem:cstep}
\end{figure*}

\begin{figure*}
	\begin{mathpar}
		\begin{array}{rc}

			\textsc{StepC} & \inferrule
			                    {(\term, \env, \fl, \ostack) \cstep \config}
													{\configa{\term}{\env}{\cstacka{\fl}{\ostack}} \step \config} \\ \\
			\textsc{StepO} & \inferrule
													{(\term, \env, k, \cstack) \ostep \config}
													{\configa{\term}{\env}{\ostacka{k}{\cstack}} \step \config}
		\end{array}
	\end{mathpar}
	\caption{Top-level Reductions -- $\config \step \config$.}
	\label{sem:top}
\end{figure*}

\section{Implementation}
\label{sec:impl}

\section{Evaluation}
\label{sec:eval}

\section{Related Work}
\label{sec:related}

\section{Conclusions and Future Work}
\label{sec:conc}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}


\end{document}
