\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Custom definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{balance}
%\usepackage{url}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{multirow}
\usepackage{microtype}
\usepackage{soul,xcolor}
\usepackage{mathpartir}
\usepackage{amsmath,amsthm}
\usepackage[utf8]{inputenc}
\input{unicode-preamble.tex}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes}
\usepackage{stmaryrd}

\crefformat{section}{ยง#2#1#3}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{nop}{}{}
\newenvironment{smathpar}{
\begin{nop}\small\begin{mathpar}}{
\end{mathpar}\end{nop}\ignorespacesafterend}

\newcommand{\kc}[1]{{\color{red} {\it [KC says: #1]}}}
\newcommand{\am}[1]{{\color{blue} {\it [AM says: #1]}}}

\definecolor{Bittersweet}{rgb}{1.0, 0.44, 0.37}
\definecolor{MidnightBlue}{rgb}{0.0, 0.2, 0.4}
\definecolor{BrightBlue}{rgb}{0.0, 0.2, 0.7}
\definecolor{byzantine}{rgb}{0.74, 0.2, 0.64}
\definecolor{caribbeangreen}{rgb}{0.0, 0.8, 0.6}

\lstset{
      language=caml,
      basicstyle=\ttfamily\footnotesize,
      flexiblecolumns=false,
      tabsize=2,
      escapechar={<@}{@>},
      %basewidth={0.5em,0.45em},
      %aboveskip={3pt},
      %belowskip={3pt},
      breaklines = true,
      breakatwhitespace = true,
      keywordstyle=\color{Bittersweet}\bfseries,
      commentstyle=\color{blue}\itshape,
      stringstyle=\color{MidnightBlue},
      keywords=[2]{},
      keywordstyle=[2]\color{byzantine}\bfseries,
      keywords=[3]{eff,effect,perform,continue,discontinue,continuation,
                   clone_continuation},
      keywordstyle=[3]\color{caribbeangreen}\bfseries,
      keywords=[4]{call,return,external},
      keywordstyle=[4]\color{Bittersweet}\bfseries,
      classoffset=1,
      upquote=true,
      keywordstyle=\color{byzantine}\bfseries,
      classoffset=0,
      mathescape=true,
      numberstyle=\tiny\color{gray},
      numbersep=5pt
}

\lstnewenvironment{code}[1][]
    { % \centering
      \lstset{
        basicstyle=\ttfamily\footnotesize,
        #1}%
      \csname lst@setfirstlabel\endcsname}
    { %\centering
      \csname lst@savefirstlabel\endcsname}

\lstMakeShortInline[columns=fullflexible,keepspaces]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Semantics definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\olam}[2]{\lambda^o #1. #2}
\newcommand{\llambda}{\lambda\!\!\lambda}
\newcommand{\clam}[2]{\lambda^c #1. #2}
\newcommand{\lam}[2]{\Lambda #1. #2}

\newcommand{\env}{\epsilon}
\newcommand{\envext}[3]{#1[#2 \mapsto #3]}

\newcommand{\oclos}[3]{\llparenthesis \olam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\cclos}[3]{\llparenthesis \clam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\clos}[3]{\llparenthesis \lam{#1}{#2}, #3 \rrparenthesis}
\newcommand{\kw}[1]{\text{\bf #1}}
\newcommand{\effval}[2]{\textsf{eff} ~#1 ~#2}
\newcommand{\exnval}[1]{\textsf{exn} ~#1}

\newcommand{\handle}[2]{\kw{match} ~#1 ~\kw{with} ~#2}
\newcommand{\throw}[2]{\kw{raise} ~#1 ~#2}
\newcommand{\perform}[2]{\kw{perform} ~#1 ~#2}

\newcommand{\caseval}[2]{\kw{return}~#1 \mapsto #2}
\newcommand{\caseexn}[3]{\kw{exception} ~#1 ~#2 \mapsto #3}
\newcommand{\caseeff}[4]{\kw{effect} ~#1 ~#2 ~#3 \mapsto #4}

\newcommand{\farg}[2]{\langle #1 ~#2 \rangle_a}
\newcommand{\ffun}[1]{\langle #1 \rangle_f}
\newcommand{\faritha}[3]{\langle #1 ~#2 ~#3 \rangle_{b1}}
\newcommand{\farithb}[2]{\langle #1 ~#2 \rangle_{b2}}

\newcommand{\kcons}{\lhd}
\newcommand{\fiber}{\varphi}
\newcommand{\fl}{\psi} % Frame List
\newcommand{\hc}{\eta} % Handler Closure

\newcommand{\cstack}{\gamma} % C Stack
\newcommand{\ostack}{\omega} % OCaml Stack
\newcommand{\cstacka}[2]{\big \lceil #1, #2 \big \rceil_c} % C stack with arguments
\newcommand{\ostacka}[2]{\big \lceil #1, #2 \big \rceil_o} % OCaml stack with arguments
\newcommand{\ostackemp}{\bullet}
\newcommand{\stack}{\sigma}

\newcommand{\term}{\tau}
\newcommand{\config}{\mathfrak{C}}
\newcommand{\configa}[3]{\|#1,#2,#3\|}

\newcommand{\ostep}{\xrightarrow{o}}
\newcommand{\cstep}{\xrightarrow{c}}
\newcommand{\step}{\rightarrow}

\begin{document}

\title{Retrofitting Effect Handlers onto OCaml}

\begin{abstract}
  Effect handlers have gained immense interest in the recent years as a means
  for modular programming with user-defined effects. The runtime semantics of
  effect handlers is particularly attractive as they allow advanced control
  flow mechanisms such as first-class continuations, generators, async/await,
  coroutines to be composably expressed. In this paper, we present the design,
  a full-fledged implementation and evaluation of effect handlers for OCaml, an
  industrial-strength, multi-paradigm programming language. OCaml tends to be
  widely used for systems programming, and is compatible with program analysis
  tools that inspect the stack such as debuggers and profilers. Retrofitting
  effect handlers onto OCaml is challenging since OCaml does not have any
  non-local control flow mechanisms other than exceptions. Our implementation
  of effect handlers for OCaml imposes negligible overhead on code that does
  not use effect handlers, and remains compatible with program analysis tools
  that inspect the stack.
\end{abstract}

\maketitle

\section{Introduction}

Effect Handlers~\cite{Plotkin09} provide a modular foundation for user-defined
effects. The key idea is to separate the definition of the effectful
\emph{operations} from their interpretations, which are defined by
\emph{handlers} of the effects. For example,
%
\begin{lstlisting}
effect Read : in_channel -> string
\end{lstlisting}
%
declares an effect |Read|, which is parameterised with an input channel of type
|in_channel|, which when \emph{performed} returns a |string| value. A
computation can perform the |Read| effect without knowing how the |Read| effect
is implemented. This computation may be enclosed by different handlers that
interpret |Read| differently. For example, |Read| may be implemented by
performing a blocking read on the input channel or performing the read
asynchronously by offloading it to an event loop such as |libuv|. Thanks to the
separation of effectful operations from their interpretations, effect handlers
enable new approaches to modular programming. A computation may perform many
different effects, which are interpreted by one or more enclosing handlers.

\subsection{An effectful calculator}

What makes effect handlers quite powerful is that they provide a structured
form of delimited continuations~\cite{}, which enables advanced non-local
control-flow mechanisms such as resumable exceptions, coroutines, generators
and asynchronous I/O to be composably expressed. As an example, consider the
task of handling division-by-zero case in a calculator application. Different
calculators handle division-by-zero differently. In the iOS 13 Calculator App
(|iOS|), division-by-zero returns |Error|. In the Google search calculator App
(|gsearch|) |0/0| returns to |Error|, and for any other |n| not equal to |0|,
|n/0| returns |Infinity| with the same sign as |n|. How can we capture these
different behaviours without changing the evaluator?

Common Lisp Conditions~\cite{Conditions} are an elegant way to solve this
problem. Unlike exceptions where the library decides whether an error is fatal
or not, conditions allow the client of the library to make that decision. If
the error is non-fatal, Conditions provide a restart mechanism to
resume execution from the point where the condition was signalled. On
division-by-zero, the calculator signals the handler and lets the handler
decide the course of action based on the desired semantics. We can implement
this mechanism using effect handlers as shown below:

\begin{lstlisting}[numbers=left]
type sign = P | N
type val = Z of int | Error | Inf of sign
type exp = Val of val | ... | Div of exp*exp
effect DivBy0 : int -> val

let rec eval e =
  match e with
  | Val v -> v
  | ...
  | Div (e1,e2) ->
    match eval e1, eval e2 with
    | Z v1, Z v2 ->
        if v2 = 0 then perform (DivBy0 v1)
        else Z (v1/v2)
    | Error, _ -> Error
    | Inf s, _ -> Inf s
    | ...

let (/) n d = Div (Val (Z n), Val (Z d))
\end{lstlisting}

On line 4, we declare an effect |DivBy0| which is parameterised by an integer,
which when performed returns a value. While interpreting the division
expression, if the denominator is 0, then we perform |DivBy0| effect with the
numerator value (line 13) so that the context may decide whether the error is
fatal or not, and resume with an appropriate value if the error is not fatal.
We can get the |iOS| semantics by wrapping the evaluator computation with the
following handler:

\begin{lstlisting}
let ios e = match eval e with
| v -> v (* value case *)
| effect (DivBy0 _) k -> (* effect case *)
    continue k Error
\end{lstlisting}

If the evaluator returns a value, we simply return that. In case the evaluator
performs the |DivBy0| effect, we catch the effect in the effect case along with
the continuation |k| of the corresponding |perform| \emph{delimited} by this
handler. In the case of |iOS|, we |continue| the suspended computation with
|Error| value. Hence, the computation |ios(1/0)| returns |Error|. On the
other hand, we can get |gsearch| semantics by enclosing the evaluator in the
following handler:

\begin{lstlisting}
let gsearch e = match eval e with
| v -> v
| effect (DivBy0 v) k ->
  if v = 0 then continue k Error
  else if v > 0 then continue k (Inf P)
  else continue k (Inf N)
\end{lstlisting}

The computation |gsearch(1/0)| returns positive infinity (|Inf P|).

\subsection{Asynchronous I/O}
\label{sec:aio}

We can extend the calculator modularly with the ability to read user input
using the |Read| effect defined earlier as follows:

\begin{lstlisting}
type exp = ... | Inp
effect Read : in_channel -> string

let rec eval e = match e with
| ...
| Inp -> int_of_string(perform(Read stdin))
\end{lstlisting}

The |Read| effect can then be handled by another handler enclosing the
division-by-zero handler:

\begin{lstlisting}
let run e = match gsearch e with
| v -> v
| effect (Read chan) k ->
  register_async_input_line (chan, k);
  let ui = get_ui_k () in
  continue ui ()
\end{lstlisting}

\noindent which registers the read operation to be performed asynchronously
with the continuation as the callback. Subsequently, it resumes the
user-interface continuation so that the application remains responsive. Observe
that neither of the handlers needs to be aware of the other.

\subsection{Retrofitting effect handlers}
\label{sec:req}

There are many research languages and libraries built around effect
handlers~\cite{Koka,Links,Pyro,Frank,Eff}. Unlike these efforts, our goal is to
retrofit effect handlers onto the OCaml programming language, which has been in
continuous use for the past 25 years in large codebases including verification
tools~\cite{FStar,Coq}, mission critical software systems~\cite{astree} and
latency sensitive networked applications~\cite{JS,Docker,MirageOS}. OCaml is
particularly favoured for its competitive yet predictable performance, with
fast foreign-function interface (FFI) and excellent compatibility with program
analysis tools such as debuggers and profilers that utilise DWARF stack unwind
tables to obtain a backtrace. Our primary motivation for adding effect handlers
to OCaml is to support (1) highly concurrent applications such as web servers
to be expressed naturally in \emph{direct-style} as opposed to using callbacks
and (2) efficient data and task parallel programs in the vein of Cilk~\cite{},
OpenMP~\cite{} and Intel TBB~\cite{}.

OCaml, however, does not support any non-local control flow mechanisms other
than exceptions. This makes it particularly challenging to implement the
delimited continuations necessary for effect handlers without sacrificing the
desirable properties of OCaml. One standard way of implementing continuations
is to use continuation-passing style (CPS) in the compiler's intermediate
representation (IR)~\cite{Koka}. If the compiler were to use CPS, then reifying
continuations in the source language is relatively straight-forward. But OCaml
does not use CPS IR, and changing the OCaml compiler to utilise CPS IR would be
an enormous undertaking. CPS IR would also affect the performance profile of
OCaml applications due to increased memory allocations as continuation closures
get allocated on the heap~\cite{Folklore}. Moreover, with CPS, stack unwinding
is meaningless and hence, we would lose compatibility with tools that inspect
the program stack. Hence, we choose not to CPS translation. The alternative is
to use the call stack for implementing continuation. Farvardin et
al~\cite{Folklore} show that there is a spectrum of implementation strategies
for continuation with different trade-offs.

The search for an expressive effect system that guarantees that all the effects
performed in the program are handled (\emph{effect safety}) in the presence of
advanced features such as polymorphism, modularity and generativity is an
active area of research~\cite{Leijen14, Biernacki19, Biernacki20,
Hillerstrom20}. We do not focus on this question in this paper, and our
implementation of effect handlers in OCaml does not guarantee effect safety.
For example, running |perform (Read stdin)| without an enclosing handler raises
exception |Unhandled| at the point of |perform|. We leave the question of
effect safety for future work.

\subsection{Requirements}
\label{sec:requirements}

We motivate our implementation strategy based on the following ideal
requirements:

\begin{enumerate}[label=R\arabic*]
  \item \textbf{Backwards compatibility} A well behaved OCaml program does not
    break under OCaml extended with effect handlers. OCaml code that does not
    use effect handlers will pay negligible performance cost.
  \item \textbf{Tool compatibility} OCaml with effect handlers produce
    well-formed backtraces, and remains compatible with program analysis tools
    such as debuggers and profilers that inspect the stack using DWARF unwind
    tables.
  \item \textbf{Effect handler efficiency} In order to support
    highly-concurrent applications, the program must accommodate millions of
    continuations in the heap. Installing effect handlers, capturing and
    resuming continuations must be fast.
  \item \textbf{Forwards compatibility} While this work does not present an
    effect system, the design must be compatible with a future effect system
    for OCaml. As a cornerstone of modularity, we also want blocking I/O code
    to \emph{transparently} be made asynchronous with the help of effect
    handlers.
\end{enumerate}

The need to host millions of active continuations in the heap rules out the use
of large contiguous stack space as in C for continuations. Instead, we resort
to using small initial stacks and growing the stacks on demand. As a result,
OCaml functions, irrespective of whether they use effect handlers, need to
perform stack overflow checks and external C functions, which do not have stack
overflow checks, must be performed on a separate stack. Additionally, we must
generate DWARF stack unwind tables for stacks that may be non-contiguous and
contain frames from different languages. In this work, we develop the compiler
and runtime support for implementing efficient effect handlers for OCaml.

Our work is also timely. WebAssembly~\ref{} community group is actively
considering effect handlers as one of the mechanism for supporting concurrency,
asynchronous I/O and generators~\ref{WasmPropoal}. Project Loom~\cite{} is an
OpenJDK project which adds virtual threads and delimited continuations to Java.
Swift concurrency roadmap~\cite{} includes direct-style asynchronous
programming and structured concurrency. We believe that our design choices will
inform similar choices to be made in the other languages.

\subsection{Contributions}

Our contributions are to present:

\begin{itemize}
  \item the design and implementation of affine effect handlers for OCaml. Our
    design retains OCaml's compatibility with program analysis tools that
    inspect the stack using DWARF unwind tables. We have validated our DWARF
    unwind tables using an automated validator tool~\cite{}.
  \item a formal operation semantics for the effect handler implementation in
    OCaml.
  \item extensive evaluation which shows that our implementation has negligible
    impact on code that does not use effect handlers, and serves as an
    efficient foundation for scalable concurrent and parallel programming.
\end{itemize}

We have implemented effect handlers in a multicore extension of the OCaml
programming language. We call our implementation ``Multicore OCaml'' to
distinguish it from stock OCaml. Multicore OCaml uses effect handlers as the
mechanism to express user-level concurrency.

The rest of the paper is organized as follows. We describe the details of the
OCaml program stack in the next section, and highlight the features that the
effect handler implementation must retain in order to provide backwards
compatibility. In \S\ref{sec:refine}, we refine the design further
focussing on the issues that come up when integrating effect handlers into a
mainstream language. \S\ref{sec:semantics} presents the formal operational
semantics for Multicore OCaml effect handlers. \S\ref{sec:impl} discusses the
compiler and the runtime system support for implementing effect handlers.
\S\ref{sec:eval} presents extensive performance evaluation of effect handlers
against the goals set in \S\ref{sec:req}. \S\ref{sec:related} and
\S\ref{sec:conc} present the related work and the conclusions.

\section{Background: OCaml Stacks}
\label{sec:stack}

\begin{figure*}
\begin{minipage}{0.59\linewidth}
  \begin{minipage}{\linewidth}
    \begin{lstlisting}[numbers=left]
external ocaml_to_c : unit -> int = "ocaml_to_c"
exception E1
exception E2

let c_to_ocaml () = raise E1
let _ = Callback.register "c_to_ocaml" c_to_ocaml

let omain () =
  try (* h1 *)
    try (* h2 *) ocaml_to_c () with E2 -> 0
  with E1 -> 42;;

let _ = assert (omain () = 42)
    \end{lstlisting}
    \subcaption{\texttt{meander.ml}}
    \label{code:meander_ml}
  \end{minipage}
  \begin{minipage}{\linewidth}
    \begin{lstlisting}[language=c,numbers=left]
#include <caml/mlvalues.h>
#include <caml/callback.h>

value ocaml_to_c (value unit) {
  caml_callback(*caml_named_value("c_to_ocaml"), Val_unit);
  return Val_int(0);
}
    \end{lstlisting}
    \subcaption{\texttt{meander.c}}
    \label{code:meander_c}
  \end{minipage}
\end{minipage}
  \begin{minipage}{0.39\linewidth}
    \centering
    \includegraphics[scale=0.46]{figures/stock_stack}
    \subcaption{Stack layout before raising exception.}
    \label{fig:stock_stack}
  \end{minipage}
  \caption{Program stack on stock OCaml.}
\end{figure*}

The main challenge in implementing effect handlers in Multicore OCaml is
managing the program stack. To this end, in this section, we provide an
overview of the program stack and related mechanisms for stock OCaml.

In order to illustrate the layout of the stock OCaml stack, consider the
program in Figures~\ref{code:meander_ml} and~\ref{code:meander_c}. The OCaml
main function |omain| installs two exception handlers |h1| and |h2| to handle
exceptions |E1| and |E2|. |omain| calls the external C function |ocaml_to_c|,
which in turn calls back into OCaml function |c_to_ocaml|, which raises the
exception |E1|. OCaml supports raising exceptions in C as well as throwing
exceptions across external calls. Hence, the exception |E1| gets caught in the
handler |h1|, and |omain| returns |42|. The layout of the stack in native code
backend just before raising the exception in |c_to_ocaml| is illustrated in
Figure~\ref{fig:stock_stack}. The stack grows downwards.

OCaml uses the hardware stack as C, and hence the program stack has alternating
sequences of C and OCaml frames. Unlike C, OCaml does not create pointers into
OCaml frames. OCaml uses the hardware support for |call| and |return|
instructions for function calls and returns. OCaml does not perform explicit
stack overflow checks in code, and, just like C, relies on the guard page at
the end of the stack region to detect stack overflow. Stack overflow is
detected by a memory fault, and |Stack_overflow| exception is raised to unwind
the stack.

\subsection{External calls and callbacks}

OCaml does not use the C calling convention. In particular, there are no
callee-saved registers in OCaml. On the |x86-64| backend, a register each is
pinned for the \emph{allocation pointer} into the minor heap used for bump
pointer allocation, and the |Caml_state|, a table of global variables used by
the runtime. These registers are chosen to be C callee saved registers. This
makes external calls extremely fast in OCaml. If the external function does not
allocate in the OCaml heap, then the external functions can be called directly,
and no bookkeeping is necessary. For external functions which allocate in the
OCaml heap, the cached allocation pointer is saved to a field in the
|Caml_state| before the external call, and loaded back on return. Similarly,
callbacks into OCaml are also cheap. Callbacks into OCaml involves loading the
arguments in the right registers and calling the OCaml function. OCaml
callbacks are relatively common as the garbage collector (GC) finalisation
functions are executed as OCaml callbacks.

\subsection{Exception handlers}

The lack of callee-saved registers also makes exception handling fast as there
are no callee-saved registers to be restored when the exception handler runs.
Hence, installing an exception handler simply pushes the program counter (pc)
of the handler and the current exception pointer (|exn_ptr| -- a field in
|Caml_state|). The exception pointer is also updated to be the current stack
pointer (|sp|). This creates a linked-list of exception handler frames on the
stack as shown in Figure~\ref{fig:stock_stack}. Raising an exception simply
sets |sp| to |exn_ptr|, loads the saved |exn_ptr|, and jumps to the |pc| of the
handler.

In order to forward exceptions across C frames, the C stub function
|caml_start_program|, which is the entry point for both the main OCaml code and
callbacks into OCaml, pushes an exception handler frame that forwards the
exception the innermost OCaml exception handler (|raised_exn_c| in
Figure~\ref{fig:stock_stack}), or prints a fatal error (|fatal_uncaught|) if
there are no enclosing handlers. Exceptions are so cheap in OCaml that it is
very common to use them for \emph{local} control flow.

\subsection{DWARF unwind tables}

OCaml also generates precise DWARF unwind information for OCaml, thanks to
which debuggers such as |gdb| and |lldb|, and profilers such as |perf| work
out-of-the-box. For example, for the program in Figures~\ref{code:meander_ml}
and~\ref{code:meander_c}, one could set a break point in |gdb| at
|caml_raise_exn| to get the following backtrace.

\begin{lstlisting}[language=c,basicstyle=\ttfamily\footnotesize]
% gdb ./meander.exe
(gdb) break caml_raise_exn
Breakpoint 1 at 0x3e5dc
(gdb) r
Starting program: meander.exe
Breakpoint 1, 0x925dc in caml_raise_exn ()
(gdb) bt
#0  0x925dc in caml_raise_exn ()
#1  0x6fd3e in camlMeander__c_to_ocaml_83 () at meander.ml:5
#2  0x925a4 in caml_start_program ()
#3  0x8a84a in caml_callback_exn (...) at callback.c:145
#4  caml_callback (...) at callback.c:199
#5  0x76e0a in ocaml_to_c (unit=1) at meander_.c:5
#6  0x6fd77 in camlMeander__omain_88 () at meander.ml:10
#7  0x6fe92 in camlMeander__entry () at meander.ml:14
#8  0x6f719 in caml_program ()
#9  0x925a4 in caml_start_program ()
#10 0x92e4c in caml_startup_common (...) at startup_nat.c:162
#11 0x92eab in caml_startup_exn (...) at startup_nat.c:167
#12 caml_startup (...) at startup_nat.c:172
#13 0x6f55c in main (...) at main.c:44
\end{lstlisting}

\noindent which corresponds to the stack layout in
Figure~\ref{fig:stock_stack}.

The same backtrace can also be obtained by using \emph{frame pointers} instead
of DWARF unwind tables. OCaml allows compiling code with frame pointers, but
they are not enabled by default. OCaml stack tends to be deep with small frames
due to the pervasive use of recursive functions, not all of which are
tail-recursive. Hence, the addition of frame pointers can significantly
increase the size of the
stack~\footnote{https://github.com/ocaml/ocaml/issues/5721\#issuecomment-472965549}.
Moreover, not using frame pointers saves two instructions in the function
prologue and epilogue, and makes an extra register (|rbp| on x86) available.

In summary, the design of effect handlers in OCaml must accommodate these
desirable properties of OCaml with respect to the program stack.

\section{Refining the design}
\label{sec:refine}

In this section, we refine the effect handler design for the OCaml use case.
The primary motivation for adding effect handlers to OCaml is to support
non-local control flow mechanism to implement asynchronous I/O in direct style,
generators and enable task parallelism. These use cases do not resume the
continuations more than once. Hence, our continuations are one-shot, and
resuming the continuation more than once raises |Invalid_argument _| exception.
It is well-known that one-shot continuations can be implemented
efficiently~\cite{Bruggeman96RepresentingControl}.

While OCaml permits throwing exceptions across C frames, we do not allow
effects to propagate across C frames as the C frames would become part of the
captured continuation. Managing C frames as part of the continuation is a
complex endeavour~\cite{Daan17Aplas}, and we find that the complexity budget
outweighs the relatively fewer mechanisms enabled by this addition in our
setting.

The interaction of non-local control flow with systems programming is quite
subtle~\cite{TFP17}. Consider the following function that uses blocking I/O
functions from the OCaml standard library to copy data from the input channel
|ic| to the output channel |oc|:

\begin{lstlisting}
let rec copy ic oc =
  try
    let l = input_line ic in
    output_string oc (l ^ "\n");
    copy ic oc
  with _ -> (close_in ic; close_out oc)
\end{lstlisting}

|input_line| raises |End_of_file| exception on reaching the end of input.
Although not apparent, the code is written in a defensive style to handle other
exceptional cases such as the channels being closed externally. Both
|input_line| and |output_string| raise |Sys_error| exception if the channel is
closed. This function cleanly closes the channels on exceptional cases;
|close_*| functions do nothing if the channel is already closed.

One of our goals(\S\ref{sec:requirements}) is to make this code transparently
asynchronous. We can define effects for performing the I/O operations:
\begin{lstlisting}
effect In_line : in_channel -> string
effect Out_str : out_channel -> string -> unit
\end{lstlisting}
\noindent and wrap them up in functions with the same signature as the one from
the standard library.
\begin{lstlisting}
let input_line ic = perform (In_line ic)
let output_string oc = perform (Out_str oc)
\end{lstlisting}

We can then use a top-level I/O handler similar to the introductory example
(\S\ref{sec:aio}) to discharge the I/O operations asynchronously. This handles
value return cases, but what about the exceptional cases |End_of_file| and
|Sys_error|? We introduce a |discontinue| primitive to resume a continuation by
raising an exception. In this example, on reaching the end of file, we would
discontinue the continuation of the |copy| function with |discontinue k End_of_file|,
which raises the exception at |input_line|, and the open channels
will be closed.

Program that use resources such as channels are usually written defensively
with the assumption that calling a function will return \emph{exactly once},
either normally or exceptionally. Since effect handlers in Multicore OCaml do
not ensure that all the effects are handled, if the function performs an effect
with no matching handler, then the function \emph{will not return at all}. To
remedy this, when such an effect bubbles up to the top-level, we discontinue
the continuation with |Unhandled| exception so that the exception handlers may
run and clean up the resources.

\section{Semantics}
\label{sec:semantics}

In this section, we formalise the effect handler design in Multicore OCaml.

\subsection{Static semantics}

As mentioned earlier, effect handlers in Multicore OCaml do not guarantee
effect safety, but only guarantee type safety. Programs without matching effect
handlers are well-typed Multicore OCaml programs. As a result, our static
semantics is simpler than languages that ensure effect
safety~\cite{Links,Koka,Effekt,Frank,HeliumBiernacki}. This is important for
backwards compatibility as our goal is to retrofit effect handlers to a
language with large legacy codebases. Programs that do not use effects remain
well-typed, and those that do compose well with those that don't.

The static semantics of effect handlers in OCaml is captured succinctly by its
API:
\begin{lstlisting}
type 'a eff = ..
type ('a,'b) continuation
val perform: 'a eff -> 'a
val continue: ('a,'b) continuation -> 'a -> 'b
val discontinue: ('a,'b) continuation -> exn -> 'b

(* Internal API *)
type 'a comp = unit -> 'a
type ('a,'b) handler =
{retc: 'a -> 'b;
 effc: 'c.'c eff -> ('c,'b)continuation -> 'b; }
val match_with: 'a comp -> ('a,'b) handler -> 'b
\end{lstlisting}

We introduce an extensible variant type~\cite{} |'a eff| of effect values,
which when performed using the |perform| primitive returns a |'a| value.
Constructors for the value of type |'a eff| are declared using the effect
declarations. For example, the declaration |effect E : string -> int| is
syntactic sugar for adding a new constructor to the variant type
|type _ eff += E : string -> int eff|. We introduce the type
|('a,'b) continuation| of delimited continuations which expect a |'a| value for
resumption and return |'b| value. The continuations may be |continue|d with a
suitably typed value or |discontinue|d with an exception.

For handling the effects, our implementation extends OCaml's |match ... with|
syntax with effect patterns. The expression
\begin{lstlisting}
match e with
| None -> false | Some b -> b
| effect (E s) k1 -> e1 | effect (F f) k2 -> e2
\end{lstlisting}
\noindent is translated to the equivalent of
\begin{lstlisting}
match_with (fun () -> e)
{ retc = (function None -> false | Some b -> b);
  effc = (function
    | (E s) -> (fun k1 -> e1)
    | (F f) -> (fun k2 -> e2)
    | e -> (fun k -> match perform e with
            | v -> continue k v
            | exception e -> discontinue k e)); }
\end{lstlisting}
For the sake of exposition, we introduce a |('a,'b) handler| type. This handler
handles a |'a comp| that returns a |'a| value, and itself returns a |'b| value.
The handler has a return case of type |'a -> 'b|. The effect case |effc|
handles effects of type |'c eff| with |('c,'b) continuation| and returns a
value of type |'b|. The last pattern in |effc| forwards any unhandled effect to
the outer handler and returns the value and exceptions back.

\subsection{Dynamic semantics}

\begin{figure*}
  \begin{minipage}[t]{0.49\linewidth}
  \begin{smathpar}
  \begin{array}{rrcl}
    \text{Constants} & n & \coloneqq & โค \\
    \text{Abstractions} & \Lambda & \coloneqq & \lambda^o \mid \lambda^c \\
    \text{Expressions} & e & \coloneqq & n \mid x \mid e ~e \mid  \lam{x}{e} \mid e \odot e \mid \throw{l}{e} \\
                       &   & \mid      & \handle{e}{h} \mid \perform{l}{e} \\
    \text{Handlers} & h & \coloneqq & \{\caseval{x}{e}\} \mid \{\caseexn{l}{x}{e}\} \uplus h \\
                   &   & \mid & \{\caseeff{l}{x}{k}{e}\} \uplus h \\
    \text{Values} & v & \coloneqq & n \mid k \mid \clos{x}{e}{\env} \mid \effval{l}{k} \mid \exnval{l} \\
    \text{Frames} & r & \coloneqq & \farg{e}{\env} \mid \ffun{v} \mid \faritha{\odot}{e}{\env} \mid \farithb{\odot}{โ} \\
    \text{Environments} & \env & \coloneqq & \emptyset \mid \envext{\env}{x}{v} \\
  \end{array}
  \end{smathpar}
  \end{minipage}
  \begin{minipage}[t]{0.49\linewidth}
  \begin{smathpar}
  \begin{array}{rrcl}
    \text{Handler Closures} & \hc & \coloneqq & (h,\env) \\
    \text{Frame List} & \fl & \coloneqq & [] \mid r :: \fl \\
    \text{Fibers} & \fiber & \coloneqq & (\fl, \hc) \\
    \text{Continuations} & k & \coloneqq & [] \mid \fiber \kcons k \\
    \text{C stacks} & \cstack & \coloneqq & \cstacka{\fl}{\ostack}\\
    \text{OCaml stacks} & \ostack & \coloneqq & \ostacka{k}{\cstack} \mid \ostackemp \\
    \text{Stacks} & \stack & \coloneqq & \cstack \mid \ostack \\
    \text{Terms} & \term & \coloneqq & e \mid v \\
    \text{Configurations} & \config & \coloneqq & \configa{\tau}{\env}{\stack}
  \end{array}
  \end{smathpar}
  \end{minipage}
  \caption{Syntax of expressions and configurations}
  \label{sem:syntax}
\end{figure*}

We present the operational semantics for a core language of effect handlers in
Multicore OCaml. The operational semantics intends to faithfully capture the
semantics of Multicore OCaml effect handlers, and to inform an implementation.
We will highlight the differences whenever we differ from the semantics of the
implementation. We have included an executable version of the dynamic semantics
as an OCaml program in the supplementary material \kc{include hl-semantics.ml}.

\subsubsection{Syntax}

Figure~\ref{sem:syntax} presents the syntax of expressions and configurations.
Our expressions consists of integer constants ($n$), variables ($x$),
abstraction ($\lam{x}{x}$), application ($e~e$), arithmetic expressions ($e
\odot e$) where $\odot$ ranges over $\{+,-,*,/\}$, raising exceptions
($\throw{l}{e}$), performing effects ($\perform{l}{e}$), and handling effects
($\handle{e}{h}$). Abstractions come in two forms: OCaml abstractions
($\lambda^o$) and C abstractions ($\lambda^c$). The handler consists of a
return case ($\caseval{x}{e}$), zero or more exception cases
($\caseexn{l}{x}{e}$) with label $l$, parameter $x$ and body $e$, and zero or
more effect cases ($\caseeff{l}{x}{k}{e}$) with label $l$, parameter $x$,
continuation $k$ and body $e$.

The operational semantics is an extension of a CEK machine
semantics~\cite{Felleisen} for effect handlers, following the abstract machine
semantics of Hillerstrom et al.~\cite{Hillerstrom2020}. The crucial difference
from Hillerstrom et al. is that our stacks are composed of alternating sequence
of OCaml and C stack segments. The program state is captured as configuration
$\config \coloneqq \configa{\tau}{\env}{\stack}$ with the current term $\tau$
under evaluation, its environment $\env$ and the current stack $\stack$. The
term is either an expression $e$ or a value $v$. The value are integer
constants $n$, continuations $k$, closure $\clos{x}{e}{\env}$, effect begin
performed $\effval{l}{k}$ and exception being raised $\exnval{l}$. The
environment is a map from variables to values.

The stack $\stack$ is either a C stack ($\cstack$) or an OCaml stack
($\ostack$). Every C stack $\cstacka{\fl}{\ostack}$ consists of a list of
frames $\fl$, and, importantly, the OCaml stack $\ostack$ under it. Every OCaml
stack is either an empty stack $\ostackemp$ or non-empty $\ostacka{k}{\cstack}$
with the C stack $\cstack$ under it. Thus the stack is an alternating sequence
of C and OCaml stacks terminating with an empty OCaml stack $\ostackemp$. The
frame list $\fl$ is composed of individual frames $r$, which is one of an
argument frame $\farg{e}{\env}$ with the expression $e$ at the argument
position of an application with its environment $\env$, a function frame
$\ffun{v}$ with the value at the function position of an application, and
frames for evaluating the arguments of an arithmetic expression.

Continuations $k$ are either empty $[]$ or non-empty sequence of \emph{fibers}.
A fiber $\fiber \coloneqq (\fl,\hc)$ is a list of frames $\fl$ and a handler
closure $\hc \coloneqq (h,\env)$, which is a pair of handler $h$ and its
environment $\env$.

\subsubsection{Top-level reductions}

\if{0}
\begin{figure}
  \begin{mathpar}
    \begin{array}{rc}
      \textsc{StepC} & \inferrule
                          {(\term, \env, \fl, \ostack) \cstep \config}
                          {\configa{\term}{\env}{\cstacka{\fl}{\ostack}} \step \config} \\ \\
      \textsc{StepO} & \inferrule
                          {(\term, \env, k, \cstack) \ostep \config}
                          {\configa{\term}{\env}{\ostacka{k}{\cstack}} \step \config}
    \end{array}
  \end{mathpar}
  \caption{Top-level Reductions -- $\config \step \config$.}
  \label{sem:top}
\end{figure}
\fi

\begin{figure}
  \begin{mathpar}
    \begin{array}{cc}
      \textsc{StepC} ~
      \inferrule{(\term, \env, \fl, \ostack) \cstep \config}
                {\configa{\term}{\env}{\cstacka{\fl}{\ostack}} \step \config} &
      \textsc{StepO} ~
      \inferrule{(\term, \env, k, \cstack) \ostep \config}
                {\configa{\term}{\env}{\ostacka{k}{\cstack}} \step \config}
    \end{array}
  \end{mathpar}
  \caption{Top-level Reductions -- $\config \step \config$.}
  \label{sem:top}
\end{figure}

The initial configuration for an expression $e$ is
$\configa{e}{\emptyset}{\cstacka{[]}{\bullet}}$, where the environment and the
stack are empty. The top-level reductions (Figure~\ref{sem:top}) can be
performed by either by taking a C step $\cstep$ or an OCaml step $\ostep$.
Intuitively, this splits the world into executing C code and OCaml code.

\begin{figure*}
  \begin{smathpar}
    \begin{array}{rrcl}
      \textsc{Var}     & (x,\env, \fl) & \rightsquigarrow
                       & (\env(x), \env, \fl) \\
      \textsc{Arith1}  & (e_1 \odot e_2, \env, \fl) & \rightsquigarrow
                       & (e_1,\env, \faritha{\odot}{e_2}{\env}::\fl) \\
      \textsc{Arith2}  & (n_1, \_, \faritha{\odot}{e_2}{\env}::\fl) & \rightsquigarrow
                       & (e_2, \env, \farithb{\odot}{n_1}::\fl) \\
      \textsc{Arith3}  & (n_2, \env, \farithb{\odot}{n_1}::\fl) & \rightsquigarrow
                       & (\llbracket n_1 \odot n_2 \rrbracket, \env, \fl) \\
      \textsc{App1}    & (e_1 ~e_2, \env, \fl) & \rightsquigarrow
                       & (e_1, \env, \farg{e_2}{\env}::\fl) \\
      \textsc{App2}    & (\lam{x}{e}, \env, \fl) & \rightsquigarrow
                       & (\clos{x}{e}{\env}, \env, \fl) \\
      \textsc{App3}    & (\clos{x}{e_1}{\env_1}, \_, \farg{e_2}{\env_2}::\fl) & \rightsquigarrow
                       & (e_2, \env_2, \ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
      \textsc{Resume1} & (k,\_,\farg{e_1}{\env_1}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
                       & (e_1, \env_1, \ffun{k}::\farg{e_2}{\env_2}::\fl) \\
      \textsc{Resume2} & (\clos{x}{e_1}{\env_1}, \_, \ffun{k}::\farg{e_2}{\env_2}::\fl) & \rightsquigarrow
                       & (e_2, \env_2, \ffun{k}::\ffun{\clos{x}{e_1}{\env_1}}::\fl) \\
      \textsc{Perform} & (\perform{l}{e}, \env, \fl) & \rightsquigarrow
                       & (e, \env, \ffun{\effval{l}{[[],(\{\caseval{x}{x}\},\emptyset)]}}::\fl) \\
      \textsc{Raise}   & (\throw{l}{e}, \env, \fl) & \rightsquigarrow
                       & (e, \env, \ffun{\exnval{l}}::\fl)
    \end{array}
  \end{smathpar}
  \caption{Administrative Reductions -- $(\term, \env, \fl) \rightsquigarrow (\tau, \env, \fl)$.}
  \label{sem:step}
\end{figure*}
\begin{figure*}
  \begin{smathpar}
    \begin{array}{rrcll}
      \textsc{AdminC}   & (\term,\env,\fl,\ostack) & \cstep
                        & \configa{\term'}{\env'}{\cstacka{\fl'}{\ostack}}
                        & \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
      \textsc{RetToO}   & (v,\env,[],\ostacka{k}{\cstack}) & \cstep
                        & \configa{v}{\env}{\ostacka{k}{\cstack}} \\
      \textsc{CallC}    & (v, \_, \cclos{x}{e}{\env}::\fl, \ostack) & \cstep
                        & \configa{e}{\envext{\env}{x}{v}}{\cstacka{\fl}{\ostack}} \\
      \textsc{Callback} & (v, \_, \oclos{x}{e}{\env}::\fl, \ostack) & \cstep
                        & \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstacka{\fl}{\ostack}}}
                        & \text{if } k = [[],(\{\caseval{x}{x}\},\emptyset)] \\
      \textsc{ExnFwdO}  & (v, \env, \ffun{\exnval{l}}::\_, \ostacka{(\fl,\hc) \kcons k}{\cstack}) & \cstep
                        & \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl,\hc) \kcons k}{\cstack}}
    \end{array}
  \end{smathpar}
  \caption{C Reductions -- $(\term, \env, \fl, \ostack) \cstep \config$.}
  \label{sem:cstep}
\end{figure*}


\subsubsection{C reductions}

The C reduction steps are given in Figure~\ref{sem:cstep}. We can take a C step
by taking an administrative reduction step $\rightsquigarrow$. The
administrative reductions are common to both C and OCaml. The rules
\textsc{Var}, \textsc{Arith1}, \textsc{Arith2}, \textsc{App1}, \textsc{App2}
and \textsc{App3} are standard. \textsc{Arith3} performs the arithmetic
operation on the integers ($\llbracket n_1 \odot n_2 \rrbracket$).
\textsc{Raise} pushes an function frame with exception value to indicate that
an exception is being raised. Similarly, \textsc{Perform} pushes a function
frame with an effect value with an empty continuation
$[[],(\{\caseval{x}{x}\},\emptyset)]$ with no captured frames and an empty
handler with an identity return case alone. \textsc{Resume1} and
\textsc{Resume2} are used for resuming continuations, and we shall defer their
explanation till later.

Continuing with the rest of the C reduction steps, \textsc{CallC} captures the
behaviour of calling a C function. Since the program is currently executing C,
indicated by the current stack being a C stack $\cstacka{\fl}{\ostack}$, we can
perform the call on the current stack. In case the abstraction is an OCaml
abstraction (\textsc{Callback}), we create an OCaml stack with the C stack as
its tail, with the current continuation being empty. This captures the
behaviour of calling back into OCaml from C. \textsc{RetToO} returns a value to
the enclosing OCaml stack. \textsc{ExnFwdO} forwards a raised exception to the
enclosing OCaml stack, ignoring the unwinding the rest of the frames. This
captures the semantics of raising OCaml exceptions from C.

\subsubsection{OCaml Reductions}

\begin{figure*}
  \begin{smathpar}
    \begin{array}{rrcll}
      \textsc{AdminO}   & (\term,\env,(\fl,\hc) \kcons k,\cstack) & \ostep
                        & \configa{\term'}{\env'}{\ostacka{(\fl',\hc) \kcons k}{\cstack}}
                        & \text{if } (\term,\env,\fl) \rightsquigarrow (\term',\env',\fl') \\
      \textsc{RetToC}   & (v, \_, [([],(h,\emptyset))], \cstack) & \ostep
                        & \configa{v}{\env}{\cstack}
                        & \text{if } h = \{\caseval{x}{x}\} \\
      \textsc{RetFib} & (v, \_, ([],(h,\env)) \kcons k, \cstack) & \ostep
                        & \configa{e}{\envext{\env}{x}{v}}{\ostacka{k}{\cstack}}
                        & \text{if } \{\caseval{x}{e}\} \in h \\
      \textsc{CallO}    & (v, \_, (\oclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
                        & \configa{e}{\envext{\env}{x}{v}}{\ostacka{(\fl,\hc) \kcons k}{\cstack}} \\
      \textsc{ExtCall}  & (v, \_, (\cclos{x}{e}{\env}::\fl,\hc) \kcons k, \cstack) & \ostep
                        & \configa{e}{\envext{\env}{x}{v}}{\cstacka{[]}{\ostacka{(\fl,\hc) \kcons k}{\cstack}}} \\
      \textsc{Resume}   & (v, \_, (\ffun{k}::\ffun{\oclos{x}{e}{\env}}::\fl,\hc) \kcons k, \cstack) & \ostep
                        & \configa{e}{\envext{\env}{x}{v}}{\ostacka{k ~@~ ((\fl,\hc) \kcons k')}{\cstack}} \\
      \textsc{Handle}   & (\handle{e}{h}, \env, k, \cstack) & \ostep
                        & \configa{e}{\env}{\ostacka{([],(h,\env)) \kcons k}{\cstack}} \\
      \textsc{EffUnHn}  & (v, \_, [\ffun{\effval{l}{k}}::\fl,(h,\env)], \cstack) & \ostep
                        & \configa{e}{\emptyset}{\ostacka{k ~@~ [(\fl,(h,\env))]}{\cstack}}
                        & \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
                  & & & & \text{and } {e = \throw{\textsf{unhandled}}{0}} \\
      \textsc{EffHn}    & (v, \_, (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons k', \cstack) & \ostep
                        & \configa{e}{\env[r \mapsto k''][x \mapsto v]}{\ostacka{k'}{\cstack}}
                        & \text{if } \{\caseeff{l}{x}{r}{e}\} \in h \\
                  & & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
      \textsc{EffFwd}   & (v, \env', (\ffun{\effval{l}{k}}::\fl,(h,\env)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
                        & \configa{v}{\env'}{\ostacka{(\ffun{\effval{l}{k''}}::\fl',\hc') \kcons k'}{\cstack}}
                        & \text{if } \{\caseeff{l}{\_}{\_}{\_}\} \notin h \\
                  & & & & \text{and } k'' = k ~@~ [(\fl,(h,\env))] \\
      \textsc{ExFwdC}   & (v, \env, [\ffun{\exnval{l}}::\_,(h,\_)], \cstacka{\fl'}{\ostack}) & \ostep
                        & \configa{v}{\env}{\cstacka{\ffun{\exnval{l}}::\fl'}{\ostack}}
                        & \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
      \textsc{ExHn}     & (v, \_, (\ffun{\exnval{l}}::\_,(h,\env)) \kcons k', \cstack) & \ostep
                        & \configa{e}{\envext{\env}{x}{v}}{\ostacka{k'}{\cstack}}
                        & \text{if } \{\caseexn{l}{x}{e}\} \in h \\
      \textsc{ExFwdFib} & (v, \env, (\ffun{\exnval{l}}::\_,(h,\_)) \kcons (\fl',\hc') \kcons k', \cstack) & \ostep
                        & \configa{v}{\env}{\ostacka{(\ffun{\exnval{l}}::\fl',\hc') \kcons k'}{\cstack}}
                        & \text{if } \{\caseexn{l}{\_}{\_}\} \notin h \\
    \end{array}
  \end{smathpar}
  \caption{OCaml Reductions -- $(\term, \env, k, \cstack) \ostep \config$.}
  \label{sem:ostep}
\end{figure*}

OCaml reductions are given in Figure~\ref{sem:ostep}. In OCaml, reductions
always occur on the top-most fiber in the current stack. \textsc{AdminO}
performs administrative reductions. \textsc{CallO} evaluates an OCaml function
on the current stack. \textsc{ExtCall} captures the behaviour of external
calls. On an external call, we create a C stack with no frames, whose tail is
the current OCaml stack, and evaluate the C functions body in the new stack.
\textsc{RetToC} returns a value to the enclosing C stack. We have exactly one
fiber on the stack, and this was created in the rule \textsc{Callback}, whose
handler has identity return case alone and the environment is empty.
\textsc{RetFib} returns value from a fiber to the previous one, evaluating the
body of the return case.

The rule \textsc{Handle} installs a handler by pushing a fiber with no frames
and the given handler. The rule \textsc{ExHn} handles an exception, if the
current handler has a matching exception case. Observe that fiber on which the
exception was raise has been unwound. The rule \textsc{ExFwdC} forwards the
exception to C. Here, there is exactly one fiber on the current stack, and the
handler does not have a matching exception case. The rule \textsc{ExFwdFib}
forwards the exception to the next fiber if the current handler does not handle
it.

The rule \textsc{EffHn} captures the handling of effects when the current
handler has a matching effect case. We evaluate the body of the matching case,
and bind the continuation parameter |r| to the captured continuation. Observe
that the captured continuation |k''| includes the current handler. Intuitively,
the handler wraps around captured continuation. This gives Multicore OCaml
effect handlers deep handler semantics~\cite{}. \textsc{EffFwd} forwards the
effect to the outer fiber, and extends the captured continuation |k''| in the
process. Recall that we do not capture C frames as part of a continuation.
\textsc{EffUnHn} models unhandled effect. If the effect bubbles up to the top
fiber, which we know does not have an effect case (see \textsc{Callback} rule),
we raise \textsc{unhandled} exception at the point where the corresponding
effect was performed. This is achieved by appending the captured continuation
to the front of the current continuation.

Observe that |continue| and |discontinue| are not part of the expressions. They
are encoded as follows:
\begin{smathpar}
  \begin{array}{rcl}
    \textsf{continue} ~k ~e & = & k ~(\olam{x}{x}) ~e \\
    \textsf{discontinue} ~k ~l ~e & = & k ~(\olam{x}{\throw{l}{x}}) ~e
  \end{array}
\end{smathpar}

Intuitively, resuming a continuation in both the cases involves evaluating the
appropriate abstraction on top of the continuation. We perform the
administrative reductions \textsc{Resume1} and \textsc{Resume2} to evaluate the
arguments to |continue| and |discontinue|. The rule \textsc{Resume} appends the
given continuation to the front of the current continuation, and evaluates the
body of the closure.

\section{Implementation}
\label{sec:impl}

\section{Evaluation}
\label{sec:eval}

\section{Related Work}
\label{sec:related}

\section{Conclusions and Future Work}
\label{sec:conc}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}


\end{document}
